# BMI270 IMU SPI接続ガイド：マイコンによる起動、初期化、データ読み取り

## 1.0 はじめに：BMI270の概要と本ガイドの目的

### 1.1 BMI270の主要機能の紹介

Bosch Sensortec社のBMI270は、単なる加速度センサーやジャイロスコープの集合体ではありません。インテリジェントなオンチップ機能を搭載した、高性能な6軸慣性計測ユニット（IMU）です。ホストとなるマイクロコントローラーの負荷を軽減しながら、高精度なモーション検知を実現できるため、特にウェアラブルデバイスやバッテリー駆動のIoT機器など、リソースに制約のある組み込みシステムにおいて絶大な価値を発揮します。本セクションでは、BMI270が提供する主要な技術的特徴を解説します。

- **6軸センサー**: 3軸加速度センサーと3軸ジャイロスコープを一つのコンパクトなパッケージに統合しています。これにより、デバイスの直線的な動き（加速度）と回転運動（角速度）を同時に、かつ同期して計測することが可能です。これらのデータは、あらゆるモーションベースのアプリケーションにおける姿勢推定（Orientation Estimation）の基礎となります。
- **低消費電力**: 加速度センサーとジャイロスコープの両方をノーマルモードで動作させた際の標準的な消費電流は、わずか685 µAです。この極めて低い消費電力は、バッテリー寿命が製品競争力を直接左右するウェアラブルデバイスやヒアラブルデバイスにおいて、大きなアドバンテージとなります。
- **オンチップFIFO**: 2 KBの大容量FIFO（First-In, First-Out）バッファを内蔵しています。これにより、マイクロコントローラーはセンサーデータをリアルタイムでポーリングし続ける必要がなくなります。一定量のデータをFIFOに蓄積してから一括で読み出すことで、マイクロコントローラーをスリープ状態に保つ時間を最大化し、システム全体の消費電力を劇的に削減できます。また、高速なデータサンプリング時においても、データの取りこぼしを防ぎます。
- **インテリジェント機能**: BMI270は、単にデータを計測するだけでなく、そのデータを内部で処理するインテリジェントな機能を多数搭載しています。例えば、手首装着時のステップカウンター、各種モーション検知（Significant Motion/Any Motion）、アクティビティ認識（静止/歩行/走行）などが挙げられます。これらの機能を活用することで、従来はホストプロセッサが担っていた複雑なアルゴリズム処理をセンサー側でオフロードし、システムの設計を簡素化できます。

### 1.2 本ガイドの対象読者とゴール

本ガイドは、BMI270を**SPI（Serial Peripheral Interface）**経由でマイクロコントローラーに接続し、基本的なセンサーデータの読み取りを行うことを目指す、すべての組み込みシステム開発者を対象としています。

本ガイドのゴールは、電源投入から安定したデータ取得までの一連の流れを、具体的な手順と注意点を交えてマスターすることです。最終的には、読者の皆様が自信を持ってBMI270を自身のプロジェクトに組み込めるようになることを目指します。

次のセクションでは、BMI270との全ての通信の基礎となるSPIプロトコルの詳細について解説します。このプロトコルを正確に理解することが、安定したセンサー動作を実現するための第一歩となります。

---

## 2.0 SPI通信プロトコルの基礎

### 2.1 導入：マイコン-BMI270間通信の確立

BMI270の設定変更からデータ読み取りまで、全ての操作はデジタルインターフェースを介して行われます。特にSPIは高速通信が可能であり、多くのマイクロコントローラーでサポートされています。このセクションでは、BMI270とSPI通信を確立するためのプロトコルと物理的な接続、そして具体的な操作シーケンスについて解説します。これらのルールを正確に理解し実装することが、信頼性の高いデータ取得に不可欠です。

BMI270は電源投入後、デフォルトではI²Cモードで起動しますが、簡単な操作でSPIモードに切り替えることができます。

1. **電源投入後のCSBピン操作**: 最も一般的で確実な方法です。BMI270のインターフェースは、電源投入直後はデフォルトでI²Cモードに設定されています。初回のダミーリードを実行することが、CSBピンに必要な立ち上がりエッジ（Low→High）を提供し、インターフェースを確実にSPIモードに切り替えるための標準的な手法です。 この操作（例：CHIP_IDレジスタ0x00の読み取り）を省略すると、センサーはSPIコマンドに応答しません。
2. **永続的なSPIモード設定**: NV_CONFレジスタ（アドレス0x70）のspi_enビットを1に設定し、不揮発性メモリ（NVM）に書き込むことで、電源投入のたびにCSBピンを操作することなく、永続的にSPIモードで起動させることが可能です。

### 2.2 SPIのモードと物理接続

BMI270とマイクロコントローラーをSPIで接続する際の主要な仕様は以下の通りです。

- **対応モード**: SPI通信には複数のモード（クロック極性CPOLとクロック位相CPHAの組み合わせ）が存在しますが、BMI270は以下の2つのモードに対応しています。
  - モード '00' (CPOL=0, CPHA=0)
  - モード '11' (CPOL=1, CPHA=1)

  マイクロコントローラー側のSPI設定を、いずれかに合わせる必要があります。

- **4線式と3線式**:
  - **4線式（デフォルト）**: CSB（チップセレクト）、SCx（クロック）、SDx（マスターからの入力）、SDO（センサーからの出力）の4本の信号線を使用します。
  - **3線式**: IF_CONFレジスタ（アドレス0x6B）のspi3ビットを1に設定することで、3線式モードに切り替えることができます。このモードでは、データ線がSDxピンに集約され、双方向通信に使用されます。

| インターフェース | BMI270 ピン | 説明 |
|--------------|-------------|------|
| **4-Wire SPI** | CSB | チップセレクト |
| | SCx | シリアルクロック |
| | SDx | シリアルデータ入力 (SDI) |
| | SDO | シリアルデータ出力 (SDO) |
| **3-Wire SPI** | CSB | チップセレクト |
| | SCx | シリアルクロック |
| | SDx | シリアルデータ I/O (SDA) |

### 2.3 読み取り操作（Read Operation）

レジスタから1バイトのデータを読み取る際のSPI通信シーケンスは、以下のステップで構成されます。特に、BMI270の仕様としてダミーバイトの存在に注意が必要です。

1. マスター（マイコン）がCSBをLowにし、通信を開始します。
2. マスターは、SDx（SDI）ピンから8ビットのコマンドを送信します。このコマンドは、読み取りビット(R/W=1)と7ビットのレジスタアドレスで構成されます。
3. マスターはクロックを送信し続け、SDOピンから最初のダミーバイトを受信します。このダミーバイトは無効なデータであり、必ず破棄する必要があります。
4. マスターはさらに8クロックを送信し、SDOピンから目的のレジスタデータ（2バイト目）を受信します。
5. マスターがCSBをHighに戻し、通信を終了します。

**重要**: **「BMI270のSPI読み取りでは、必ず1バイトのダミーリードが発生する」**というルールは、ドライバーを実装する上で最も重要なポイントの一つです。これを考慮しないと、データが1バイトずれてしまい、正常な値を読み取ることができません。これは実装時に見落とされがちな、よくある失敗点です。

### 2.4 書き込み操作（Write Operation）

レジスタに1バイトのデータを書き込む際のSPI通信シーケンスは、読み取り操作よりもシンプルです。

1. マスター（マイコン）がCSBをLowにし、通信を開始します。
2. マスターは、SDx（SDI）ピンから8ビットのコマンドを送信します。このコマンドは、書き込みビット(R/W=0)と7ビットのレジスタアドレスで構成されます。
3. マスターは続けて、SDx（SDI）ピンから書き込みたい8ビットのデータを送信します。
4. マスターがCSBをHighに戻し、通信を終了します。

### 2.5 通信タイミングに関する重要事項

信頼性の高い通信を実現するためには、以下のタイミング要件を遵守する必要があります。

- **最大クロック周波数**: I/O電源電圧（VDDIO）が1.62V以上の場合、SPIクロックの最大周波数は**10 MHz**です。
- **書き込み後のアイドルタイム**: レジスタへの書き込み操作後、次のアクセスを開始するまでに必要な待機時間（アイドルタイム）は、センサーの動作モードによって大きく異なります。この遅延の遵守は非常に重要です。この待機時間を無視すると、書き込みが正しく反映されない可能性があります。
  - **通常モード (Normal mode)**: 少なくとも**2 µs** (t_IDLE_wr_act) の待機時間が必要です。
  - **サスペンド/低電力モード (Suspend/Low-power mode)**: 少なくとも**450 µs** (t_IDLE_wacc_sum) の待機時間が必要です。この時間は通常モードに比べて非常に長いため、低電力モードでのレジスタ設定時には特に注意が必要です。

これらのプロトコルとタイミング規約を正確に実装することが、次のステップであるセンサーの初期化シーケンスを成功させるための絶対的な前提条件となります。

---

## 3.0 起動シーケンスと必須の初期化

### 3.1 導入：センサーを動作可能状態にするための鍵

BMI270は、電源を投入しただけではセンサーとして機能しません。センサー内部のインテリジェント機能を司るプロセッサを起動し、Bosch Sensortecが提供する独自のコンフィギュレーションファイルをロードするという、厳密な初期化シーケンスが必要です。このシーケンスを正確に実行することが、BMI270の性能を最大限に引き出すための鍵となります。手順を一つでも誤るとセンサーは正しく動作せず、プロジェクトの遅延に繋がる可能性があるため、慎重な実装が求められます。

### 3.2 詳細な初期化手順

マイクロコントローラーが実行すべき具体的な初期化手順は以下の通りです。レジスタ名、アドレス、書き込み値、そして待機時間を正確に守ってください。

1. **電源投入後の待機**: 電源（VDDおよびVDDIO）が安定した後、レジスタにアクセス可能になるまで**450 µs**以上待機します。この待機は非常に重要です。これを怠ると、センサーが内部的に準備完了状態になる前にコマンドを送信してしまい、初期化に失敗する一般的な原因となります。

2. **SPIインターフェースの確立**: セクション2.1で解説した通り、ダミーのレジスタ読み出し（例：CHIP_IDレジスタ 0x00）を実行し、インターフェースを確実にSPIモードに設定します。

3. **アドバンストパワーセーブの無効化**: PWR_CONFレジスタ（アドレス 0x7C）に 0x00 を書き込み、アドバンストパワーセーブモード（APS）を無効にします。初期化中はセンサー内部のプロセッサがアクティブになるため、この設定が必須です。
   ```c
   write_reg(0x7C, 0x00);
   ```

4. **待機**: レジスタ書き込み後、内部状態が安定するまで**450 µs**以上待機します。この待機時間もクリティカルであり、省略することはできません。

5. **設定ファイルのロード準備**: INIT_CTRLレジスタ（アドレス 0x59）に 0x00 を書き込み、設定ファイルのアップロード準備が整ったことをセンサーに通知します。
   ```c
   write_reg(0x59, 0x00);
   ```

6. **設定ファイルのアップロード**:
   - Bosch Sensortecが提供する公式のコンフィギュレーションファイル（bmi270_config_file、約8KB）を準備します。このファイルは、公式のGitHubリポジトリから入手できます。
     - 参照: https://github.com/BoschSensortec/BMI270-Sensor-API/blob/master/bmi270.c
   - この設定データを、INIT_DATAレジスタ（アドレス 0x5E）に対して、SPIのバースト書き込み機能を使用して一括で送信します。
   - **注記（メモリ制約のあるマイコン向け）**: ホストマイコンのRAMバッファが8KBより小さい場合、設定ファイルを一度に送信できないことがあります。その場合、データをより小さなチャンク（塊）に分割して書き込むことが可能です。各チャンクを書き込む間に、INIT_ADDR_0 (0x5B) と INIT_ADDR_1 (0x5C) レジスタに、次に書き込むデータの開始アドレスを書き込む必要があります。具体的には、書き込んだチャンクのバイト数 ÷ 2 だけアドレスをインクリメントします。

7. **設定ファイルのロード完了**: アップロードが完了したら、INIT_CTRLレジスタ（アドレス 0x59）に 0x01 を書き込み、初期化プロセスの完了をセンサーに伝えます。
   ```c
   write_reg(0x59, 0x01);
   ```

### 3.3 初期化完了の確認方法

初期化シーケンスが正しく完了したかを確認することは、その後の動作の信頼性を保証する上で非常に重要です。以下の手順で確認を行ってください。

- INIT_CTRLレジスタに0x01を書き込んだ後、INTERNAL_STATUSレジスタ（アドレス 0x21）を定期的に読み出し（ポーリング）します。
- このレジスタの下位4ビットで構成されるmessageフィールドの値が 0b0001 (0x01) になるのを待ちます。この値は「ASIC initialized」を意味します。
- この確認プロセスには、最大で**20 ms**かかる可能性があります。
- もし0x01以外の値が返された場合（例：0x02 "Initialization error"）、初期化シーケンスに何らかの問題があったことを示します。その場合は、待機時間や書き込み手順に誤りがないか再度確認してください。

この初期化プロセスが成功すると、BMI270は「コンフィギュレーションモード」に移行します。この状態になって初めて、センサーの有効化やデータレートの設定など、次のステップに進む準備が整います。

---

## 4.0 センサーデータの読み取り

### 4.1 導入：初期化後のデータ取得準備

厳密な初期化シーケンスが完了し、BMI270は設定を受け付ける「コンフィギュレーションモード」に入りました。しかし、この段階ではまだセンサーはデータを生成していません。次のステップとして、目的のデータを取得するために、加速度センサーとジャイロスコープを個別に有効化し、それぞれの動作モードや出力データレート（ODR）を設定する必要があります。この設定は、アプリケーションが要求するデータの更新頻度と、システムの消費電力とのトレードオフを決定する重要なプロセスです。

### 4.2 センサーの有効化と基本設定

加速度センサーとジャイロスコープを有効化し、基本的な設定を行う手順は以下の通りです。

#### センサーの有効化

PWR_CTRLレジスタ（アドレス 0x7D）を使用して、各センサーの電源を個別に制御します。

- 加速度センサーを有効にするには、acc_enビット（ビット2）を1にします。
- ジャイロスコープを有効にするには、gyr_enビット（ビット1）を1にします。
- 温度センサーを有効にするには、temp_enビット（ビット3）を1にします。

#### 動作モードとデータレートの設定

センサーの性能（フィルター特性）と出力データレート（ODR）は、それぞれ専用のコンフィギュレーションレジスタで設定します。

##### 加速度センサーの設定（ACC_CONF: 0x40）

**ACC_CONFレジスタのビット構成**:
- **bits 3:0** (acc_odr): 出力データレート（ODR）
- **bit 7** (acc_filter_perf): フィルター性能モード
  - 0 = Power optimized（省電力優先）
  - 1 = Performance（性能優先、推奨）

**加速度センサーのODR設定値**:

| ODR        | レジスタ値 (bits 3:0) | 備考 |
|------------|----------------------|------|
| 0.78 Hz    | 0x01 | 超低速（特殊用途） |
| 1.5 Hz     | 0x02 | - |
| 3.1 Hz     | 0x03 | - |
| 6.25 Hz    | 0x04 | 低速モニタリング |
| 12.5 Hz    | 0x05 | - |
| 25 Hz      | 0x06 | 低消費電力 |
| 50 Hz      | 0x07 | 標準モニタリング |
| **100 Hz** | **0x08** | **推奨（一般用途）** |
| 200 Hz     | 0x09 | 高速サンプリング |
| 400 Hz     | 0x0A | - |
| 800 Hz     | 0x0B | 非常に高速 |
| 1600 Hz    | 0x0C | 最高速（特殊用途） |

##### ジャイロスコープの設定（GYR_CONF: 0x42）

**GYR_CONFレジスタのビット構成**:
- **bits 3:0** (gyr_odr): 出力データレート（ODR）
- **bit 7** (gyr_filter_perf): フィルター性能モード
  - 0 = Power optimized（省電力優先）
  - 1 = Performance（性能優先、推奨）

**ジャイロスコープのODR設定値**:

| ODR        | レジスタ値 (bits 3:0) | 備考 |
|------------|----------------------|------|
| 25 Hz      | 0x06 | 低速モニタリング |
| 50 Hz      | 0x07 | - |
| 100 Hz     | 0x08 | 標準モニタリング |
| **200 Hz** | **0x09** | **推奨（一般用途）** |
| 400 Hz     | 0x0A | 高速サンプリング |
| 800 Hz     | 0x0B | 非常に高速 |
| 1600 Hz    | 0x0C | - |
| 3200 Hz    | 0x0D | 最高速（特殊用途） |

##### フィルター性能モードの選択

- **Performance mode (bit 7 = 1)**: より正確なフィルタリング、ノイズが少ない（推奨）
- **Power optimized mode (bit 7 = 0)**: 消費電力を最小化、若干のノイズ増加

一般的なアプリケーションでは **Performance mode** を推奨します。

##### ACC_CONF と GYR_CONF の値の計算

レジスタ値は以下のように計算します：

```c
uint8_t acc_conf = odr_value | (filter_perf << 7);
uint8_t gyr_conf = odr_value | (filter_perf << 7);
```

例:
- 100Hz, Performance mode: `0x08 | 0x80 = 0x88` (0b10001000)
- 200Hz, Performance mode: `0x09 | 0x80 = 0x89` (0b10001001)
- 100Hz, Power optimized: `0x08 | 0x00 = 0x08` (0b00001000)

#### 設定例

加速度センサーを100Hz、ジャイロスコープを200Hzの「Performance モード」で動作させる場合、以下の値を書き込みます。

```c
// 1. 加速度、ジャイロ、温度センサーを有効化
write_reg(0x7D, 0x0E);  // PWR_CTRL: 0b00001110

// 2. 加速度センサー設定（100Hz, Performance mode）
write_reg(0x40, 0x88);  // ACC_CONF: ODR=100Hz (0x08), filter_perf=1 (0x80)

// 3. ジャイロスコープ設定（200Hz, Performance mode）
write_reg(0x42, 0x89);  // GYR_CONF: ODR=200Hz (0x09), filter_perf=1 (0x80)
```

#### ODR選択の指針

- **加速度センサー**:
  - 一般的なモーションセンシング: 100Hz（推奨）
  - 高速動作解析: 400Hz～800Hz
  - 低消費電力モード: 25Hz～50Hz

- **ジャイロスコープ**:
  - 一般的な姿勢推定: 200Hz（推奨）
  - 高精度姿勢制御: 400Hz～800Hz
  - 低消費電力モード: 100Hz

**重要**: 加速度とジャイロのODRを異なる値に設定することも可能です。ただし、FIFO使用時はヘッダーモードを有効にして、データフレームを正しく識別する必要があります。

### 4.3 ダイレクトレジスタ読み取り

センサーを有効化し設定が完了すると、データレジスタから直接センサー値を読み取ることができます。

#### データレジスタのアドレス

各軸のデータは16ビット（2バイト）で格納されています。

- **加速度データ (X, Y, Z)**: DATA_8 (0x0C) から DATA_13 (0x11)
- **ジャイロスコープデータ (X, Y, Z)**: DATA_14 (0x12) から DATA_19 (0x17)

#### データ形式

データは16ビットの2の補数表現です。2つの8ビットレジスタ（LSB: 下位バイト, MSB: 上位バイト）から読み出した後、16ビットの符号付き整数に結合して使用します。

#### シャドウイング手順の重要性

データの完全性を保証するため、BMI270には「シャドウイング」と呼ばれる重要な仕組みが備わっています。マルチバイトのデータを読み取っている最中に値が更新されてしまい、上位バイトと下位バイトで異なるサンプル時点のデータが混在する（データが破損する）ことを防ぎます。

**このルールは非常にシンプルです。各軸のデータは、必ずLSB（下位バイト）のレジスタから読み取ってください。** LSBレジスタが読み取られると、その瞬間に対応するMSB（上位バイト）レジスタの値が内部的にロック（シャドウイング）されます。これにより、次にMSBレジスタを読み取る際には、LSBと同じサンプル時点の値が保証されます。

ダイレクトレジスタ読み取りは最もシンプルで直感的なデータ取得方法ですが、高い頻度でデータを読み取る場合、マイクロコントローラーの処理負荷が増大します。より効率的なデータ収集方法として、次章で解説するFIFOの活用が推奨されます。

### 4.4 レンジ設定とスケール係数

センサーから読み取った16ビットの生データ（LSB: Least Significant Bit）を物理的な単位（加速度は g、角速度は °/s）に変換するには、現在設定されているレンジに応じたスケール係数を使用する必要があります。

#### 加速度センサーのレンジ設定

加速度センサーの測定レンジは、**ACC_RANGE レジスタ（アドレス 0x41）** で設定します。このレジスタの下位2ビット（bits 1:0）がレンジ設定値です。

| レンジ | レジスタ値 (bits 1:0) | スケール係数 | 分解能 |
|--------|----------------------|-------------|--------|
| ±2g    | 0x00 | 16384 LSB/g | 0.061 mg/LSB |
| ±4g    | 0x01 | 8192 LSB/g  | 0.122 mg/LSB |
| ±8g    | 0x02 | 4096 LSB/g  | 0.244 mg/LSB |
| ±16g   | 0x03 | 2048 LSB/g  | 0.488 mg/LSB |

**設定例**:

```c
// ±4g レンジに設定
write_reg(0x41, 0x01);  // ACC_RANGE = 0x01
```

**デフォルト値**: ±2g（レジスタ値 0x00）

#### ジャイロスコープのレンジ設定

ジャイロスコープの測定レンジは、**GYR_RANGE レジスタ（アドレス 0x43）** で設定します。このレジスタの下位3ビット（bits 2:0）がレンジ設定値です。

| レンジ      | レジスタ値 (bits 2:0) | スケール係数        | 分解能 |
|------------|----------------------|---------------------|--------|
| ±125 °/s   | 0x04 | 262.4 LSB/(°/s) | 0.00381 (°/s)/LSB |
| ±250 °/s   | 0x03 | 131.2 LSB/(°/s) | 0.00763 (°/s)/LSB |
| ±500 °/s   | 0x02 | 65.6 LSB/(°/s)  | 0.01526 (°/s)/LSB |
| ±1000 °/s  | 0x01 | 32.8 LSB/(°/s)  | 0.03049 (°/s)/LSB |
| ±2000 °/s  | 0x00 | 16.4 LSB/(°/s)  | 0.06098 (°/s)/LSB |

**設定例**:

```c
// ±1000 °/s レンジに設定
write_reg(0x43, 0x01);  // GYR_RANGE = 0x01
```

**デフォルト値**: ±2000 °/s（レジスタ値 0x00）

#### 生データから物理値への変換

16ビットの2の補数表現で読み取ったセンサー値を物理値に変換する式は以下の通りです：

**加速度の変換**:

```c
float accel_g = (float)raw_value / scale_factor;
```

例（±2g レンジの場合）:

```c
int16_t raw_x = 8192;  // 生データ
float accel_x_g = (float)raw_x / 16384.0f;  // = 0.5g
```

**角速度の変換**:

```c
float gyro_dps = (float)raw_value / scale_factor;
```

例（±2000 °/s レンジの場合）:

```c
int16_t raw_x = 328;  // 生データ
float gyro_x_dps = (float)raw_x / 16.4f;  // = 20.0 °/s
```

#### レンジ選択の指針

- **加速度センサー**:
  - 一般的なモーション検知: ±2g または ±4g（高分解能）
  - 衝撃検知や激しい動き: ±8g または ±16g（広範囲）

- **ジャイロスコープ**:
  - 低速回転の精密測定: ±125 °/s または ±250 °/s（高分解能）
  - 一般的なモーション: ±500 °/s または ±1000 °/s
  - 高速回転: ±2000 °/s（広範囲）

### 4.5 データ読み取りの実装パターン

#### 推奨: バースト読み取り

3軸すべてのデータを読み取る際は、シャドウイング機能を最大限活用するため、**バースト読み取り**を使用することを強く推奨します。

**加速度データのバースト読み取り（6バイト）**:

```c
uint8_t data[6];
// ACC_X_LSB (0x0C) から6バイト連続読み取り
// 順序: ACC_X_LSB, ACC_X_MSB, ACC_Y_LSB, ACC_Y_MSB, ACC_Z_LSB, ACC_Z_MSB
burst_read(0x0C, data, 6);

// データ結合（リトルエンディアン）
int16_t acc_x = (int16_t)((data[1] << 8) | data[0]);
int16_t acc_y = (int16_t)((data[3] << 8) | data[2]);
int16_t acc_z = (int16_t)((data[5] << 8) | data[4]);
```

**ジャイロデータのバースト読み取り（6バイト）**:

```c
uint8_t data[6];
// GYR_X_LSB (0x12) から6バイト連続読み取り
burst_read(0x12, data, 6);

int16_t gyr_x = (int16_t)((data[1] << 8) | data[0]);
int16_t gyr_y = (int16_t)((data[3] << 8) | data[2]);
int16_t gyr_z = (int16_t)((data[5] << 8) | data[4]);
```

#### シャドウイングの確認

- バースト読み取りでは、最初のレジスタ（LSB）を読んだ時点で、対応するすべてのMSBレジスタが内部でロックされます
- これにより、6バイトの読み取り中にデータが更新されても、一貫性のあるスナップショットが保証されます
- **重要**: 必ずLSBレジスタから読み取りを開始してください

#### 完全な読み取り例（加速度 + ジャイロ）

両方のセンサーデータを同時に取得する場合、2回のバースト読み取りを実行します：

```c
// Step 1: 加速度データ読み取り（6バイト）
uint8_t acc_data[6];
burst_read(0x0C, acc_data, 6);
int16_t acc_x = (int16_t)((acc_data[1] << 8) | acc_data[0]);
int16_t acc_y = (int16_t)((acc_data[3] << 8) | acc_data[2]);
int16_t acc_z = (int16_t)((acc_data[5] << 8) | acc_data[4]);

// Step 2: ジャイロデータ読み取り（6バイト）
uint8_t gyr_data[6];
burst_read(0x12, gyr_data, 6);
int16_t gyr_x = (int16_t)((gyr_data[1] << 8) | gyr_data[0]);
int16_t gyr_y = (int16_t)((gyr_data[3] << 8) | gyr_data[2]);
int16_t gyr_z = (int16_t)((gyr_data[5] << 8) | gyr_data[4]);

// Step 3: 物理値への変換（±2g、±2000°/s の場合）
float accel_x_g = (float)acc_x / 16384.0f;
float accel_y_g = (float)acc_y / 16384.0f;
float accel_z_g = (float)acc_z / 16384.0f;

float gyro_x_dps = (float)gyr_x / 16.4f;
float gyro_y_dps = (float)gyr_y / 16.4f;
float gyro_z_dps = (float)gyr_z / 16.4f;
```

### 4.6 温度センサーの読み取り

BMI270には、加速度センサーとジャイロスコープに加えて、**オンチップ温度センサー**が内蔵されています。この温度センサーは、主に加速度・ジャイロデータの温度補正に使用されますが、環境温度のモニタリングにも利用できます。

#### 温度センサーの仕様

| 項目 | 仕様 |
|------|------|
| 測定範囲 | -40°C ～ +85°C |
| 分解能 | 1/512 °C/LSB (約 0.002 °C/LSB) |
| 精度 | ±1°C (典型値) |
| 更新レート | 1.28秒ごと（Performance mode時） |
| データ形式 | 16ビット 2の補数表現 |
| レジスタ形式 | リトルエンディアン（LSB→MSB） |

**重要**: 温度センサーのデータは**リトルエンディアン形式**で格納されています。これは加速度・ジャイロデータと同じエンディアンです。データシートではビッグエンディアンと記載されていますが、実際のハードウェアではリトルエンディアンとして動作します。

#### 温度センサーの有効化

温度センサーは、**PWR_CTRL レジスタ（アドレス 0x7D）** の bit 3（temp_en）で有効化します。

```c
// 加速度、ジャイロ、温度センサーを有効化
uint8_t pwr_ctrl = 0x0E;  // 0b00001110
//                   ||||
//                   |||+--- bit 0: aux_en  = 0 (補助センサー無効)
//                   ||+---- bit 1: gyr_en  = 1 (ジャイロ有効)
//                   |+----- bit 2: acc_en  = 1 (加速度有効)
//                   +------ bit 3: temp_en = 1 (温度センサー有効)
write_reg(0x7D, pwr_ctrl);
```

**注意事項**:
- 温度センサーの出力値を正確に取得するには、ジャイロスコープが Normal mode（gyr_pmu_status=1）で動作している必要があります
- ジャイロスコープが Suspend mode の場合、温度センサーのデータは無効です

#### 温度データレジスタ

温度データは2つのレジスタに格納されています：

| レジスタ名 | アドレス | 内容 |
|-----------|---------|------|
| TEMP_MSB  | 0x22    | 温度データの上位8ビット |
| TEMP_LSB  | 0x23    | 温度データの下位8ビット |

#### 温度データの読み取り

温度データは、2バイトのバースト読み取りで取得します。**重要**: 温度データは**リトルエンディアン形式**（加速度・ジャイロと同じ）で格納されています。

```c
// TEMP_MSB (0x22) から2バイト連続読み取り
uint8_t temp_data[2];
burst_read(0x22, temp_data, 2);

// リトルエンディアン形式で結合
// temp_data[0] = LSB, temp_data[1] = MSB
int16_t temp_raw = (int16_t)((temp_data[1] << 8) | temp_data[0]);
```

#### 温度値の変換式

16ビットの生データを摂氏温度（°C）に変換する式は以下の通りです：

```c
float temperature_celsius = ((float)temp_raw / 512.0f) + 23.0f;
```

**変換式の構成要素**:
- **分解能**: 512 LSB/°C (= 2^9)
- **オフセット**: 23°C（室温での基準温度）

#### 読み取り例

```c
// 温度データの読み取り
uint8_t temp_data[2];
esp_err_t ret = bmi270_read_burst(dev, 0x22, temp_data, 2);
if (ret != ESP_OK) {
    ESP_LOGE(TAG, "Failed to read temperature");
    return ret;
}

// リトルエンディアンで結合（加速度/ジャイロと同じ）
// temp_data[0] = LSB, temp_data[1] = MSB
int16_t temp_raw = (int16_t)((temp_data[1] << 8) | temp_data[0]);

// 物理値への変換
float temperature = ((float)temp_raw / 512.0f) + 23.0f;

printf("Temperature: %.2f °C\n", temperature);
```

#### エンディアン形式の比較

BMI270のデータレジスタは、**すべてリトルエンディアン**です：

| センサー | レジスタ順序 | エンディアン | 結合方法 |
|---------|-------------|------------|---------|
| 加速度   | ACC_X_LSB (0x0C), ACC_X_MSB (0x0D) | リトル | `(MSB << 8) \| LSB` |
| ジャイロ | GYR_X_LSB (0x12), GYR_X_MSB (0x13) | リトル | `(MSB << 8) \| LSB` |
| 温度     | TEMP_MSB (0x22), TEMP_LSB (0x23)   | **リトル** | `(data[1] << 8) \| data[0]` |

**注意**: バースト読み取りの開始アドレスが異なります：
- 加速度/ジャイロ: LSBアドレスから開始（例: 0x0C）
- 温度: MSBアドレスから開始（0x22）
  - バースト読み取り時: `data[0]` = 0x22の値（LSB）, `data[1]` = 0x23の値（MSB）

#### 温度センサーの用途

1. **温度補正（Temperature Compensation）**:
   - 加速度・ジャイロのオフセットやゲインは温度によって変化します
   - 温度データを使用して、ソフトウェアで補正計算を行うことができます

2. **環境モニタリング**:
   - デバイスの動作温度を監視し、過熱保護などに利用できます
   - ただし、センサー内部の温度であり、外部環境温度とは異なる可能性があります

3. **データ品質の評価**:
   - 温度が急激に変化している場合、センサーデータの信頼性が低下する可能性があります
   - 温度トレンドを監視することで、データの品質を評価できます

#### トラブルシューティング

**症状**: 温度値が異常（極端に高い/低い、不安定）

**考えられる原因と対策**:

1. **温度センサーが有効化されていない**:
   - PWR_CTRL レジスタの bit 3（temp_en）が 0 になっている
   - 対策: `PWR_CTRL = 0x0E` を設定し、temp_en を 1 にする

2. **ジャイロスコープが Suspend mode**:
   - 温度センサーの出力にはジャイロが Normal mode である必要があります
   - 対策: PWR_CTRL の bit 1（gyr_en）を 1 に設定

3. **エンディアンの誤り**:
   - ビッグエンディアンで読み取っている（データシート記載だが実際は異なる）
   - 対策: 温度も加速度/ジャイロと同じリトルエンディアンで読み取る `(data[1] << 8) | data[0]`

4. **変換式の誤り**:
   - スケール係数やオフセットが間違っている
   - 対策: 正しい式 `(temp_raw / 512.0) + 23.0` を使用

#### 正常な温度値の目安

- **室温環境**: 約 20°C ～ 30°C
- **連続動作時**: 約 30°C ～ 40°C（センサー内部の自己発熱）
- **高負荷時**: 約 40°C ～ 60°C（センサー + ホストプロセッサの発熱）

**異常値の例**:
- 85°C 以上: 変換式の誤り、またはエンディアンの誤り（ビッグエンディアンで読み取っている）
- -30°C 以下（室温環境で）: エンディアンの誤り（ビッグエンディアンで読み取っている）、または温度センサー未有効化
- 値が頻繁に反転（+85°C ↔ -30°C）: 温度センサーが有効化されておらず、未定義データを読み取っている
- 起動直後のみ不安定: 正常（温度センサーは1.28秒ごと更新、起動後数秒で安定）

### 4.7 割り込み機能（Data Ready）

BMI270には、データ準備完了時にマイクロコントローラーに通知する**Data Ready割り込み**機能があります。ポーリング方式と比較して、CPU負荷を削減し、データ取得のタイミングを正確に制御できます。

#### 割り込み機能の利点

**ポーリング方式の課題**:
- CPU負荷が高い（常にセンサーをチェック）
- データ取得タイミングが不正確
- 消費電力が大きい

**割り込み方式の利点**:
- **イベント駆動**: データ準備完了時のみ処理
- **CPU負荷削減**: 待機中はスリープ可能
- **正確なタイミング**: ODRに同期したデータ取得
- **低消費電力**: 必要時のみCPU稼働

#### BMI270の割り込みピン

BMI270には2つの割り込み出力ピンがあります：

| ピン名 | 説明 |
|-------|------|
| INT1 | 割り込み出力1（汎用） |
| INT2 | 割り込み出力2（汎用） |

どちらのピンも、複数の割り込みソースをマッピング可能です。

#### Data Ready割り込みの種類

| 割り込みタイプ | 説明 |
|-------------|------|
| **ACC_DRDY** | 加速度データ準備完了 |
| **GYR_DRDY** | ジャイロデータ準備完了 |

これらは個別に有効化でき、INT1またはINT2ピンにマッピングできます。

#### 割り込み設定の手順

**Step 1: 割り込み出力ピンの設定（INT1_IO_CTRL / INT2_IO_CTRL）**

INT1_IO_CTRLレジスタ（アドレス 0x53）またはINT2_IO_CTRLレジスタ（アドレス 0x54）で出力特性を設定します。

| ビット | 名前 | 設定値 | 説明 |
|-------|------|--------|------|
| bit 0 | output_en | 1 | 割り込み出力を有効化 |
| bit 1 | lvl | 0/1 | 0=Active Low, 1=Active High |
| bit 2 | od | 0/1 | 0=Push-Pull, 1=Open-Drain |

**推奨設定**: Push-Pull, Active High
```c
uint8_t int1_io_ctrl = 0x0B;  // 0b00001011
//                         |||
//                         ||+--- bit 0: output_en = 1 (有効)
//                         |+---- bit 1: lvl = 1 (Active High)
//                         +----- bit 2: od = 0 (Push-Pull)
write_reg(0x53, int1_io_ctrl);  // INT1_IO_CTRL
```

**Step 2: Data Ready割り込みのマッピング（INT1_MAP_FEAT / INT2_MAP_FEAT）**

INT1_MAP_FEATレジスタ（アドレス 0x56）またはINT2_MAP_FEATレジスタ（アドレス 0x57）で割り込みソースをピンにマッピングします。

**注意**: Data Ready割り込みはINT_MAP_DATAレジスタ（アドレス 0x58）で設定します。

```c
// INT_MAP_DATA レジスタ（アドレス 0x58）
uint8_t int_map_data = 0x04;  // 0b00000100
//                        |
//                        +--- bit 2: drdy_int1 = 1 (Data Ready → INT1)

write_reg(0x58, int_map_data);
```

**INT_MAP_DATA レジスタのビット割り当て**:
- bit 2: `drdy_int1` - Data Ready割り込みをINT1にマッピング
- bit 6: `drdy_int2` - Data Ready割り込みをINT2にマッピング

**Step 3: Data Ready割り込みの有効化（INT1_INT2_MAP_DATA）**

実際には、Step 2のINT_MAP_DATAレジスタ設定で割り込みがマッピングされます。

#### ESP32側のGPIO割り込み設定

BMI270からの割り込み信号を受け取るには、ESP32側でGPIO割り込みを設定する必要があります。

```c
// M5StampFlyの場合、INT1ピンはGPIO11に接続されています
#define BMI270_INT1_PIN 11

// GPIO設定
gpio_config_t io_conf = {
    .pin_bit_mask = (1ULL << BMI270_INT1_PIN),
    .mode = GPIO_MODE_INPUT,
    .pull_up_en = GPIO_PULLUP_DISABLE,
    .pull_down_en = GPIO_PULLDOWN_DISABLE,
    .intr_type = GPIO_INTR_POSEDGE  // Active High: 立ち上がりエッジ
};
gpio_config(&io_conf);

// 割り込みハンドラの登録
gpio_install_isr_service(0);
gpio_isr_handler_add(BMI270_INT1_PIN, gpio_isr_handler, NULL);
```

#### 割り込みハンドラの実装

```c
// 割り込みフラグ（ISRとメインタスク間の通信）
static volatile bool data_ready = false;

// ISR（割り込みサービスルーチン）
static void IRAM_ATTR gpio_isr_handler(void* arg) {
    data_ready = true;
}

// メインループ
while (1) {
    if (data_ready) {
        data_ready = false;

        // データ読み取り
        bmi270_accel_t accel;
        bmi270_gyro_t gyro;
        bmi270_read_accel(&dev, &accel);
        bmi270_read_gyro(&dev, &gyro);

        // データ処理...
    }

    // 割り込み待機（省電力）
    vTaskDelay(pdMS_TO_TICKS(1));
}
```

#### ラッチモードとパルスモード

BMI270の割り込み出力には、ラッチモードとパルスモードがあります。

**パルスモード（デフォルト）**:
- 割り込み条件発生時、短いパルス（2.5µs）を出力
- クリア不要、自動的にリセット
- Data Ready割り込みに適している

**ラッチモード**:
- 割り込み条件発生時、割り込みピンがHigh（またはLow）を維持
- INT1_STATUSまたはINT2_STATUSレジスタを読むことでクリア
- 複数の割り込みソースを扱う場合に有用

Data Ready割り込みでは、通常**パルスモード**を使用します。

#### トラブルシューティング

**症状**: 割り込みが発生しない

**考えられる原因と対策**:

1. **割り込み出力が無効**:
   - INT1_IO_CTRL の output_en ビットが 0
   - 対策: output_en = 1 に設定

2. **割り込みマッピングが未設定**:
   - INT_MAP_DATA レジスタの drdy_int1 ビットが 0
   - 対策: drdy_int1 = 1 に設定（0x04 を書き込む）

3. **GPIO割り込みタイプの不一致**:
   - Active Highなのに NEGEDGE で検出している
   - 対策: INT1_IO_CTRL の lvl ビットとGPIO設定を一致させる

4. **センサーが無効**:
   - PWR_CTRL で加速度/ジャイロが有効化されていない
   - 対策: PWR_CTRL = 0x06（加速度+ジャイロ）を設定

**症状**: 割り込みが連続発生する

**考えられる原因と対策**:

1. **データを読み取っていない**:
   - Data Ready割り込みは新しいデータが準備されるたびに発生
   - 対策: 割り込みハンドラ内または直後にデータを読み取る

2. **ODRが高すぎる**:
   - 処理が間に合わず、割り込みが蓄積
   - 対策: ODRを下げるか、処理を高速化

#### 性能比較：ポーリング vs 割り込み

| 項目 | ポーリング（100ms） | 割り込み |
|------|------------------|---------|
| CPU使用率 | 高（常時監視） | 低（イベント駆動） |
| データ取得タイミング | 不正確（最大100ms遅延） | 正確（ODR同期） |
| 消費電力 | 高 | 低（スリープ可能） |
| 実装複雑度 | 低 | 中（GPIO設定必要） |
| データ取りこぼし | 可能性あり（高ODR時） | なし |

**推奨用途**:
- **ポーリング**: 簡単なプロトタイプ、低速サンプリング（< 50Hz）
- **割り込み**: 本番実装、高速サンプリング（≥ 100Hz）、低消費電力が必要な場合

### 4.8 FIFO（First-In First-Out）バッファ

FIFOは、BMI270の1024バイトのハードウェアバッファで、複数のセンサーサンプルをバッチ処理することでSPI通信のオーバーヘッドを大幅に削減します。

#### FIFOの利点

| 利点 | 説明 |
|------|------|
| **高速サンプリング対応** | 800Hz以上の高ODRでもデータ損失なし |
| **SPI効率化** | 複数サンプルを一度に読み取り（バースト読み取り） |
| **低消費電力** | MCUをスリープさせ、ウォーターマーク割り込みで起動 |
| **タイムスタンプ精度** | センサー内部で正確なタイミングでサンプリング |

#### FIFOレジスタ

| レジスタ | アドレス | 機能 |
|---------|---------|------|
| FIFO_CONFIG_0 | 0x48 | FIFO動作モード設定 |
| FIFO_CONFIG_1 | 0x49 | センサー有効化、ヘッダーモード |
| FIFO_DOWNS | 0x45 | ダウンサンプリング設定 |
| FIFO_WTM_0 | 0x46 | ウォーターマーク LSB（**4バイト単位**） |
| FIFO_WTM_1 | 0x47 | ウォーターマーク MSB（10-bit値、**4バイト単位**） |
| FIFO_LENGTH_0 | 0x24 | FIFO内データ量 LSB（読み取り専用、**1バイト単位**） |
| FIFO_LENGTH_1 | 0x25 | FIFO内データ量 MSB（読み取り専用、**1バイト単位**） |
| FIFO_DATA | 0x26 | FIFOデータ読み取り |

**重要な注意事項**:
- **FIFO_WTM（ウォーターマーク）**: レジスタ値は**4バイト単位**です。例えば、512バイトのウォーターマークを設定する場合は、`512 / 4 = 128` をレジスタに書き込みます。
- **FIFO_LENGTH（データ量）**: レジスタ値は**1バイト単位**です。実際のバイト数がそのまま読み取れます。
- この単位の違いに注意しないと、ウォーターマーク割り込みが正しく動作しません。

#### FIFOフレーム構造

BMI270のFIFOは**フレーム**としてデータを格納します。フレームには**レギュラーフレーム**（センサーデータ）と**コントロールフレーム**（メタデータ）の2種類があります。

##### ヘッダーモード（推奨）

ヘッダーモードでは、各フレームは**1バイトのヘッダー**と**ペイロードデータ**で構成されます。

**ヘッダーバイト構造（1バイト）:**

| Bit 7 | Bit 6-5 | Bit 4-1 | Bit 0 |
|:---:|:---:|:---:|:---:|
| `fh_mode<1>` | `fh_mode<0>` + `fh_parm<3>` | `fh_parm<2:0>` | `fh_ext<1:0>` |

- **`fh_mode<1:0>`** (フレームモード):
  - `0b10`: レギュラーフレーム（センサーデータ）
  - `0b01`: コントロールフレーム（メタデータ）

- **`fh_parm<3:0>`** (ペイロードパラメータ):
  - **レギュラーフレームの場合** - 含まれるセンサーを示す:
    - Bit 3: 予約済み
    - **Bit 2**: `0b1` = AUXセンサーデータを含む
    - **Bit 1**: `0b1` = ジャイロスコープデータを含む
    - **Bit 0**: `0b1` = 加速度計データを含む
  - **コントロールフレームの場合** - コントロールオペコードを示す

- **`fh_ext<1:0>`** (外部タギング): INT1/INT2ピンの外部イベントタグ

**フレームヘッダー例:**
```
0x84 (0b10000100): 加速度のみ（7バイト: ヘッダー1 + ACC 6）
0x88 (0b10001000): ジャイロのみ（7バイト: ヘッダー1 + GYR 6）
0x8C (0b10001100): 加速度+ジャイロ（13バイト: ヘッダー1 + GYR 6 + ACC 6）
0x8E (0b10001110): AUX+加速度+ジャイロ（最大21バイト: ヘッダー1 + AUX 8 + GYR 6 + ACC 6）
```

##### レギュラーフレームのペイロード順序

**重要**: ペイロードデータの順序は、レジスタ`DATA_0`〜`DATA_19`の順序とは**異なります**。

**データ順序（`fh_parm=0b0111`の場合、AUX+GYR+ACCすべて含む）:**
1. **AUXデータ**（最大8バイト、`AUX_0`〜`AUX_7`）
2. **ジャイロスコープデータ**（6バイト: X, Y, Z軸のLSB/MSB）
3. **加速度計データ**（6バイト: X, Y, Z軸のLSB/MSB）

すべてのデータは**リトルエンディアン形式**（LSBが先、MSBが後）で格納されます。

**加速度+ジャイロフレーム例（13バイト）:**
```
[0]     ヘッダー: 0x8C (0b10001100 = 加速度+ジャイロ)
[1-2]   GYR_X (LSB, MSB)  ← 注意: ジャイロが先！
[3-4]   GYR_Y (LSB, MSB)
[5-6]   GYR_Z (LSB, MSB)
[7-8]   ACC_X (LSB, MSB)  ← 加速度が後！
[9-10]  ACC_Y (LSB, MSB)
[11-12] ACC_Z (LSB, MSB)
```

##### コントロールフレーム（メタデータ）

コントロールフレームはヘッダーモードでのみサポートされます。

| `fh_parm<3:0>` | 種類 | ペイロード長 | 説明 |
|:---:|:---|:---:|:---|
| `0x0` | **Skip Frame** | 1バイト | FIFOオーバーラン時にスキップされたフレーム数 |
| `0x1` | **Sensortime Frame** | 3バイト | 最後のサンプルフレーム読み出し時のセンサータイム |
| `0x2` | **Config Change Frame** | 4バイト | センサー設定変更の通知 |

##### ヘッダーレスモード

ヘッダーを無効化（`FIFO_CONFIG_1.fifo_header_en = 0b0`）すると、ヘッダーレスモードになります。

**制約:**
- **すべての有効化されたセンサー要素のODRが同一**である必要があります
- すべてのフレームが同じサイズになる必要があります
- フレーム構成変更（センサー有効化/無効化など）が発生すると、**FIFOは即座にフラッシュ**されます

##### ODRが異なる場合の動作（データ同期）

BMI270のFIFOは、加速度計とジャイロスコープのODRが異なっていても、**データを同期**させて格納します。

**データ同期の原則:**
> フレームにODR *x* のセンサー要素のサンプルが含まれている場合、そのフレームには、ODRが *y* ≥ *x* であるすべてのセンサー要素のサンプルも含まれていなければなりません。

つまり、**遅いODRに同期**して、速いODRのセンサーデータもフレームに含まれます。

**例:**
- 加速度: 100Hz、ジャイロ: 200Hz の場合
- フレーム生成レート: 100Hz（遅い方に同期）
- 各フレームには、100Hzの加速度データと、200Hzジャイロデータの最新サンプルが含まれる

**ダウンサンプリング設定（`FIFO_DOWNS` レジスタ 0x45）:**

各センサーのFIFO入力レートを調整できます。

- **`acc_fifo_downs`** / **`gyr_fifo_downs`**: ダウンサンプリング係数 $2^k$ ($k=\{0..7\}$)
- **`acc_fifo_filt_data`** / **`gyr_fifo_filt_data`**:
  - `0b1`: フィルター処理されたデータ（ODR設定に従う）
  - `0b0`: 未処理データ（ACC: 1600Hz、GYR: 6400Hz）

**例えるなら**: 複数のカメラ（センサー）が異なる速度（ODR）で写真を撮影していても、アルバム（FIFO）に保存する際は、最も遅いカメラのタイミングに合わせて、速いカメラが撮影した最新の写真も必ず一緒にセットで保存されるイメージです。

#### FIFO設定手順

```c
// Step 1: FIFOモード設定（ストリームモード）
// fifo_stop_on_full = 0: 満杯時に古いデータを上書き
uint8_t fifo_config_0 = 0x00;
bmi270_write_register(dev, 0x48, fifo_config_0);

// Step 2: 加速度+ジャイロをFIFOに格納、ヘッダーモード有効
// fifo_header_en (bit 4) = 1
// fifo_acc_en (bit 6) = 1
// fifo_gyr_en (bit 7) = 1
uint8_t fifo_config_1 = (1 << 7) | (1 << 6) | (1 << 4);  // 0xD0
bmi270_write_register(dev, 0x49, fifo_config_1);

// Step 3: ウォーターマーク設定（例: 512バイト）
// **重要**: ウォーターマークレジスタは「バイト単位」で設定します（4バイトワード単位ではない！）
// FIFO_WTM_0 (0x46): 下位8ビット (fifo_water_mark_7_0)
// FIFO_WTM_1 (0x47): 上位5ビット (fifo_water_mark_12_8, bit 4-0)
// 計算式: ウォーターマークレベル (バイト) = fifo_water_mark_7_0 + fifo_water_mark_12_8 × 256
// 512バイト ≈ 39フレーム（13バイト/フレーム）
uint16_t watermark_value = 512;  // バイト単位で直接指定
bmi270_write_register(dev, 0x46, watermark_value & 0xFF);        // LSB (bits 7-0)
bmi270_write_register(dev, 0x47, (watermark_value >> 8) & 0x1F); // MSB (bits 12-8, 13ビット値)

// Step 4: ウォーターマーク割り込みを有効化（オプション）
// **重要**: FIFO割り込みは INT_MAP_DATA (0x58) で設定します
// INT_MAP_FEAT (0x56/0x57) は高度なフィーチャー（activity recognition等）専用です
uint8_t int_map_data;
bmi270_read_register(dev, 0x58, &int_map_data);
int_map_data |= (1 << 1);  // bit 1: FIFO watermark割り込みをINT1にマップ
bmi270_write_register(dev, 0x58, int_map_data);

// INT_MAP_DATA (0x58) ビット定義:
// bit 0: FIFO full → INT1
// bit 1: FIFO watermark → INT1
// bit 2: Data ready → INT1
// bit 4: FIFO full → INT2
// bit 5: FIFO watermark → INT2
// bit 6: Data ready → INT2
```

#### FIFOウォーターマークレジスタ詳細

BMI270では、FIFOの充填レベルが設定値に達したときにホストプロセッサに通知するためのウォーターマーク機能が提供されており、これには2つのレジスタを使用します。

**ウォーターマーク設定レジスタ:**

FIFOウォーターマークレベルは、以下の2つのレジスタの値を組み合わせて設定されます。

1. **`FIFO_WTM_0`** (アドレス 0x46)
   - **ビット 7-0 (`fifo_water_mark_7_0`)**: ウォーターマークレベルの下位8ビット（読み書き可能）

2. **`FIFO_WTM_1`** (アドレス 0x47)
   - **ビット 4-0 (`fifo_water_mark_12_8`)**: ウォーターマークレベルの上位5ビット（読み書き可能）

**ウォーターマークレベルの計算と機能:**

ウォーターマークレベルは、FIFOバッファ内に格納された**バイト数**で定義されます。

- **レベルの計算:** ウォーターマークレベルは、`fifo_water_mark_7_0`（0x46）と`fifo_water_mark_12_8`（0x47）の値を組み合わせて計算されます。
  $$\text{ウォーターマークレベル (バイト)} = \text{fifo\_water\_mark\_7\_0} + \text{fifo\_water\_mark\_12\_8} \times 256$$

- **範囲:** 0〜2047バイト（13ビット値、FIFO最大サイズ2048バイト）

- **機能:** FIFOの充填レベルがこの設定されたウォーターマークレベルと**等しいか、または超えたとき**に、**FIFOウォーターマーク割り込み**が発行されます。

**ウォーターマーク割り込みの使用方法:**

ウォーターマーク機能を使用するには、以下の手順が必要です。

1. **割り込みの有効化とマッピング:**
   - FIFOウォーターマーク割り込み (`fwm_int`) は、レジスタ**`INT_STATUS_1`**（アドレス 0x1D）によって報告されます。
   - この割り込みを外部ピン（INT1またはINT2）に出力するには、レジスタ**`INT_MAP_DATA`**（アドレス 0x58）を使用し、`fwm_int1`（INT1ピンへのマッピング）または`fwm_int2`（INT2ピンへのマッピング）を設定する必要があります。

2. **低消費電力モードでの利用:**
   - 低消費電力モードでFIFOを使用する場合、`PWR_CONF.fifo_self_wakeup=0b1`（FIFO自己ウェイクアップ有効）が設定されており、**FIFOウォーターマーク割り込み**またはFIFOフル割り込みがトリガーされた場合、FIFOデータ読み出しに関する高度な省電力設定の制約（`PWR_CONF.adv_power_save=0b1`の制約）が解除されます。
   - これにより、ホストは低消費電力モードを解除することなく、単一のバーストリードでFIFO全体を読み出すことができます。

**補足情報:**

- **FIFOサイズ:** BMI270のオンチップFIFOバッファのサイズは**2048バイト**（2 KB）です。
- **FIFO充填レベルの確認:** 現在のFIFO充填レベルは、レジスタ`FIFO_LENGTH_0` (LSB, 0x24) および `FIFO_LENGTH_1` (MSB, 0x25) で確認できます。
- **FIFOフル割り込み:** ウォーターマーク割り込みとは別に、FIFOの充填レベルがフルの閾値を超えたとき（最後の2フレームが格納される直前）に「FIFOフル割り込み」が発行されます。

**例えるなら、ウォーターマークの設定は、バケツ（FIFOバッファ）に水を貯める際に、バケツが満タンになる前に「そろそろ汲み出してください」と知らせる水位計を設定するようなものです。** `FIFO_WTM_0`と`FIFO_WTM_1`はその水位計の目盛りの位置（バイト数）を定義し、設定された水位に達すると、割り込み（アラーム）が発生して、ホストプロセッサ（水を汲み出す人）に通知します。

#### FIFOデータ読み取り実装

```c
// Step 1: FIFO内のデータ量を確認
uint8_t fifo_len_buf[2];
bmi270_read_burst(dev, 0x24, fifo_len_buf, 2);
uint16_t fifo_length = (fifo_len_buf[1] << 8) | fifo_len_buf[0];

if (fifo_length == 0) {
    return ESP_OK;  // データなし
}

// Step 2: FIFOデータをバースト読み取り
uint8_t *fifo_data = malloc(fifo_length);
bmi270_read_burst(dev, 0x26, fifo_data, fifo_length);

// Step 3: ヘッダーモードでフレーム解析
size_t pos = 0;
while (pos < fifo_length) {
    uint8_t header = fifo_data[pos++];

    if ((header & 0xFC) == 0x84) {
        // 加速度のみフレーム（7バイト）
        if (pos + 6 > fifo_length) break;

        int16_t acc_x = (fifo_data[pos+1] << 8) | fifo_data[pos+0];
        int16_t acc_y = (fifo_data[pos+3] << 8) | fifo_data[pos+2];
        int16_t acc_z = (fifo_data[pos+5] << 8) | fifo_data[pos+4];
        pos += 6;

        // データ処理...

    } else if ((header & 0xFC) == 0x88) {
        // ジャイロのみフレーム（7バイト）
        if (pos + 6 > fifo_length) break;

        int16_t gyr_x = (fifo_data[pos+1] << 8) | fifo_data[pos+0];
        int16_t gyr_y = (fifo_data[pos+3] << 8) | fifo_data[pos+2];
        int16_t gyr_z = (fifo_data[pos+5] << 8) | fifo_data[pos+4];
        pos += 6;

        // データ処理...

    } else if ((header & 0xFC) == 0x8C) {
        // 加速度+ジャイロフレーム（13バイト）
        if (pos + 12 > fifo_length) break;

        int16_t acc_x = (fifo_data[pos+1] << 8) | fifo_data[pos+0];
        int16_t acc_y = (fifo_data[pos+3] << 8) | fifo_data[pos+2];
        int16_t acc_z = (fifo_data[pos+5] << 8) | fifo_data[pos+4];
        int16_t gyr_x = (fifo_data[pos+7] << 8) | fifo_data[pos+6];
        int16_t gyr_y = (fifo_data[pos+9] << 8) | fifo_data[pos+8];
        int16_t gyr_z = (fifo_data[pos+11] << 8) | fifo_data[pos+10];
        pos += 12;

        // データ処理...
    }
}

free(fifo_data);
```

#### FIFOフラッシュ

FIFOをクリアするには、CMD レジスタ (0x7E) に `0xB0` を書き込みます:

```c
bmi270_write_register(dev, 0x7E, 0xB0);  // FIFO flush command
```

#### トラブルシューティング

**症状**: FIFO_LENGTH が常に 0

**考えられる原因と対策**:

1. **FIFOが有効化されていない**:
   - FIFO_CONFIG_1 の fifo_acc_en / fifo_gyr_en ビットを確認
   - 対策: 少なくとも1つのセンサーを有効化

2. **センサーが無効**:
   - PWR_CTRL でセンサーが有効化されているか確認
   - 対策: PWR_CTRL = 0x06（加速度+ジャイロ）

3. **ODRが設定されていない**:
   - ACC_CONF / GYR_CONF でODRを設定
   - 対策: 適切なODR値を設定（例: 0x08 = 100Hz）

**症状**: フレーム解析エラー、データが壊れている

**考えられる原因と対策**:

1. **ヘッダーモードの不一致**:
   - FIFO_CONFIG_1.fifo_header_en の設定とコードが一致していない
   - 対策: ヘッダーモードを有効化してヘッダー付きで解析

2. **SPI読み取りエラー**:
   - FIFO_DATAレジスタからのバースト読み取りが失敗
   - 対策: SPI通信の安定性を確認、CS信号のタイミング確認

3. **FIFO満杯**:
   - ストリームモード(fifo_stop_on_full=0)で古いデータが上書きされた
   - 対策: ウォーターマーク割り込みでこまめに読み取る

**症状**: データ取得レートが予想より遅い

**考えられる原因と対策**:

1. **ダウンサンプリングが有効**:
   - FIFO_DOWNS レジスタを確認
   - 対策: ダウンサンプリングを無効化（0x00）またはダウンサンプル比を調整

2. **ウォーターマークが大きすぎる**:
   - 割り込みまでの時間が長い
   - 対策: ウォーターマーク値を小さくする

#### パフォーマンス比較

| 方式 | サンプリングレート | SPI通信回数/秒 | CPU負荷 |
|------|------------------|---------------|---------|
| ポーリング（100ms間隔） | 10 Hz | 10回 | 高 |
| 割り込み（200Hz ODR） | 200 Hz | 200回 | 中 |
| **FIFO（ウォーターマーク512バイト、200Hz）** | **200 Hz** | **~15回** | **低** |

FIFO使用時、39フレーム（512バイト）ごとに1回の読み取りで済むため、200Hz時でも約15回/秒のSPI通信で完了します。

**推奨用途**:
- **ポーリング**: プロトタイプ、低速（< 50Hz）
- **割り込み**: 中速（50-400Hz）、リアルタイム性重視
- **FIFO**: 高速（≥ 400Hz）、低消費電力、バッチ処理

---

## 5.0 FIFOを利用した高速データ読み取り

### 5.1 導入：FIFOの価値と利用シナリオ

FIFO（First-In, First-Out）バッファは、BMI270が持つ最も強力な機能の一つです。これを利用することで、マイクロコントローラーの負荷を劇的に削減しつつ、高速かつ欠損のないデータサンプリングが可能になります。FIFOは、センサーが取得したデータを一時的に蓄積するオンチップメモリです。マイクロコントローラーは、常にセンサーを監視する代わりに、FIFOにデータが溜まるのを待ち、必要な時に一括でデータを読み出すことができます。

このアプローチは、特に以下のようなシナリオで絶大な価値を発揮します。

- **高ODR（Output Data Rate）でのデータ収集**: 数百Hz以上の高速サンプリングを行う際、ポーリングではデータの取りこぼしが発生しがちですが、FIFOを使えば確実にデータをキャプチャできます。
- **低消費電力アプリケーション**: マイクロコントローラーを大半の時間スリープさせ、FIFOの割り込み（ウォーターマークなど）をトリガーとして短時間だけ起動させることができます。これにより、システム全体の平均消費電力を大幅に削減できます。

### 5.2 FIFOの有効化と設定

FIFOを利用するには、どのセンサーデータをFIFOに格納するか、またFIFOが満杯になったときにどう振る舞うかを設定する必要があります。

#### センサーデータのFIFO有効化

FIFO_CONFIG_1レジスタ（アドレス 0x49）を使用して、FIFOに格納するデータソースを選択します。

- 加速度データを格納する場合: fifo_acc_enビット（ビット6）を1に設定します。
- ジャイロスコープデータを格納する場合: fifo_gyr_enビット（ビット7）を1に設定します。

#### FIFOモードの設定

**ヘッダーモード / ヘッダーレスモード**: FIFO_CONFIG_1レジスタのfifo_header_enビット（ビット4）で切り替えます。ヘッダーモードを有効（1）にすると、各データフレームの先頭に、どのセンサーのデータが含まれているかなどの情報を持つヘッダーが付加されます。これにより、複数のセンサーデータを異なるレートでサンプリングしている場合でも、データを柔軟に解析できます。

**FIFO満杯時の動作**: FIFO_CONFIG_0レジスタ（アドレス 0x48）のfifo_stop_on_fullビット（ビット0）で、FIFOが満杯になった際の挙動を選択します。

- `0` (fifo_stop_on_full = 0) はストリーミングモードに対応します。最も古いデータから上書きされ、常に最新のデータが保持されます。
- `1` (fifo_stop_on_full = 1) はFIFOモードに対応します。FIFOが満杯になると、新しいデータの書き込みが停止され、データが破棄されます。

### 5.3 FIFOデータの読み出し手順

FIFOに蓄積されたデータをマイクロコントローラーが読み出す手順は、以下の通りです。

1. **FIFOデータ量の確認**: まず、FIFO_LENGTH_0（アドレス 0x24）とFIFO_LENGTH_1（アドレス 0x25）の2つのレジスタを読み出し、現在FIFOに溜まっているデータの総バイト数を確認します。

2. **バーストリードの実行**: ステップ1で確認したバイト数だけ、FIFO_DATAレジスタ（アドレス 0x26）からSPIのバースト読み取りを実行します。

3. **データの解析**: 読み出した一連のバイト列を、設定したフレーム構造に従って解析します。ヘッダーモード（fifo_header_en=1）の場合、バイトストリームは「フレーム」で構成されており、各センサーデータペイロードの前には1バイトのヘッダーが付加されます。加速度とジャイロのODRが異なる場合など、このヘッダーを解析してフレームの内容（どのセンサーデータが含まれているか）を特定することが、正確なデータ抽出に不可欠です。各フレームから加速度やジャイロのデータを抽出し、16ビットのセンサー値に変換します。

### 5.4 高度な利用法：低電力モードでのFIFO活用

FIFOの真価は、低消費電力アプリケーションで発揮されます。fifo_self_wakeup機能を利用することで、システムの消費電力を極限まで抑えることが可能です。この機能の挙動は、PWR_CONFレジスタ（アドレス 0x7C）のfifo_self_wakeupビット（ビット1）の設定によって大きく変わるため、正確な理解が重要です。

- **PWR_CONF.fifo_self_wakeup = 0b0 の場合**: この設定では、FIFO割り込み（ウォーターマークまたは満杯）が発生しても、センサーは低電力モード（アドバンストパワーセーブが有効な状態）を維持します。FIFOデータを読み出すためには、ホストマイコンがまずアドバンストパワーセーブモードを明示的に無効化（PWR_CONF.adv_power_save = 0b0）し、450 µs待機してからFIFOにアクセスする必要があります。

- **PWR_CONF.fifo_self_wakeup = 0b1 の場合 (最大電力効率)**: こちらが、真の低電力FIFO運用のための設定です。FIFO割り込みが発生すると、センサーは一時的にホストマイコンからのFIFO読み出しを受け付けられる状態になります。これにより、マイコンはスリープ状態から復帰し、アドバンストパワーセーブを無効化することなく、単一のバースト読み取りでFIFOデータを一括取得できます。データ取得後、マイコンは即座にスリープに戻ることができ、システムの平均消費電力を劇的に削減することが可能になります。この挙動の違いを理解することが、低消費電力設計を成功させる鍵となります。

---

## まとめ

本ガイドで解説した手順——信頼性の高いSPI通信の確立、厳密な初期化シーケンスの実行、そして目的に応じたデータ読み取り方法（ダイレクトリードまたはFIFO）の選択——をマスターすることで、BMI270の持つ高度な性能を最大限に引き出すことができるでしょう。
