PMW3901MB 光学モーションセンサー実装ガイド

1.0 はじめに：PMW3901MBセンサーの概要と本ガイドの目的

PMW3901MB-TXQTは、PixArt Imaging社が開発した先進的な光学式モーショントラッキングチップです。本センサーは、遠距離光学技術（Far Field Optics Technology）を採用しており、特に空中でのナビゲーションを目的として設計されています。これにより、ドローンのような飛行体において、GPS信号が利用できない屋内や特定の屋外環境でも、高精度なX-Y座標の測位とモーション検出が可能になります。その応用範囲は広く、自律的な位置決めが求められる様々なデバイスで中心的な役割を果たします。

この技術文書は、PMW3901MBセンサーを組み込みシステムのマイクロコントローラ（MCU）に接続し、その性能を最大限に引き出すための実践的な実装ガイドです。本ガイドでは、以下の3つの核心的なタスクを達成するための、ステップバイステップの手順を具体的に解説します。

1. SPIインターフェースの確立: センサーとの通信の基盤となる4線式SPIプロトコルの設定と操作方法。
2. 正しい初期化シーケンスの実行: センサーを安定して動作させるための、電源投入からレジスタ設定までの一連の必須手順。
3. モーションデータの読み出し: X-Y変位データを正確に取得するための標準的な読み出し手順と、より高速なバーストモードの活用法。

本ガイドで詳述する手順は、センサーの安定した動作と最適なパフォーマンスを保証するための鍵となります。これらの基本を確実に押さえることで、貴社のプロジェクトにおけるセンサー統合を成功に導きます。


--------------------------------------------------------------------------------


2.0 SPIインターフェースの基礎：通信の確立

PMW3901MBセンサーとの全ての通信は、4線式のSPI（Serial Peripheral Interface）を介して行われます。このインターフェースを正しく理解し、適切に設定することは、センサー内部のレジスタ設定やモーションデータの読み出しといった、あらゆる操作の前提条件となります。

SPI信号ピンの役割

センサーとの通信には、以下の4つの主要な信号ピンが使用されます。

* SCLK (Serial data clock): マスターであるマイクロコントローラが生成するクロック信号です。この信号に同期してデータの送受信が行われます。
* MOSI (Master Out / Slave In): マイクロコントローラからセンサーへデータを送信するためのデータラインです。レジスタアドレスや書き込みデータを送信する際に使用します。
* MISO (Master In / Slave Out): センサーからマイクロコントローラへデータを送信するためのデータラインです。レジスタから読み出したデータがこのラインを通じて返されます。
* NCS (Chip select): 通信対象のデバイスとしてPMW3901MBセンサーを選択・有効化するための信号です。このピンがLowレベルになることで、センサーはSPI通信を受け付けます（アクティブロー）。

SPI通信プロトコル

SPI通信は、「書き込み操作」と「読み出し操作」の2つの基本操作で構成されます。

書き込み操作 (Write Operation)

マイクロコントローラからセンサーのレジスタへデータを書き込む操作です。トランザクションは2バイトで構成されます。

1. アドレスバイト: 最初のバイトは、書き込み対象のレジスタアドレス（7ビット）と、書き込み操作を示すフラグ（1ビット）で構成されます。書き込み操作では、アドレスバイトの最上位ビット（MSB）を 1 に設定する必要があります。
2. データバイト: 2番目のバイトに、レジスタに書き込む8ビットのデータを格納します。

読み出し操作 (Read Operation)

センサーのレジスタからデータを読み出す操作です。この操作も2バイトのトランザクションです。

1. アドレスバイト: マイクロコントローラは、読み出したいレジスタのアドレス（7ビット）を含むアドレスバイトを送信します。読み出し操作では、アドレスバイトのMSBを 0 に設定する必要があります。
2. データバイト: マスターがアドレスバイト送信のための8回のSCLKサイクルを完了した後、次の8回のSCLKサイクル中に、センサー（スレーブ）が要求されたデータの8ビットをMISOラインを通じて返送します。マスター側はこのデータを受信します。

これらの基本的なSPI操作は、次のセクションで解説するセンサーの初期化シーケンスにおいて、各ステップのレジスタ設定を実行するための基盤となります。


--------------------------------------------------------------------------------


3.0 初期化と設定シーケンス：センサーの起動手順

PMW3901MBセンサーの性能を最大限に引き出し、安定した動作を保証するためには、データシートに規定された厳密な初期化シーケンスを実行することが不可欠です。この手順を省略したり、順序を誤ったりすると、センサーが期待通りに動作せず、不正確なデータを出力する原因となります。

電源投入シーケンス

電源投入からセンサーが通信可能になるまでの初期手順は以下の通りです。

1. 電源投入: VDDIOに電源を供給し、その後100ms以内にVDDに電源を供給します。
2. 待機時間: 電源が安定するまで、最低でも40ms待機します。
3. SPIポートリセット: NCSピンを一度HighにしてからLowに駆動し、SPIポートをリセットします。
4. パワーアップリセット: Power_Up_Resetレジスタ（アドレス 0x3A）に値 0x5A を書き込み、チップ全体をリセットします。
5. 待機時間: リセット処理が完了するまで、最低でも1ms待機します。
6. 初回読み出し: モーションピンの状態に関わらず、レジスタ 0x02, 0x03, 0x04, 0x05, 0x06 を一度ずつ読み出します。

パフォーマンス最適化レジスタの設定

上記の基本的なパワーアップシーケンスに続き、センサーの内部アルゴリズムを正しく構成し、最適なパフォーマンスを達成するために、以下のレジスタ設定シーケンスを実行する必要があります。これらの設定はPixArt社独自のプロプライエタリな情報であり、直接的な書き込みと条件分岐を含むロジックで構成されています。センサーの安定動作に必須の項目であるため、正確に実装してください。

まず、以下の初期設定を書き込みます。

// Address, Value
Write 0x7F, 0x00
Write 0x55, 0x01
Write 0x50, 0x07
Write 0x7F, 0x0E


次に、条件付きの検証処理を実行します。

1. 検証シーケンス:
  1. レジスタ 0x43 に 0x10 を書き込みます。
  2. レジスタ 0x47 を読み出します。
  3. 読み出した値が 0x08 であることを確認します。もし一致しない場合は、このシーケンス（ステップ1と2）を最大3回まで再試行してください。それでも成功しない場合は、エラーとして処理を停止し、センサーの電源再投入を検討してください。
2. 条件付き書き込み:
  1. レジスタ 0x67 を読み出します。
  2. 読み出した値のビット7がセットされている（1である）場合、レジスタ 0x48 に 0x04 を書き込みます。
  3. ビット7がセットされていない（0である）場合、レジスタ 0x48 に 0x02 を書き込みます。

続いて、以下の設定を書き込みます。

// Address, Value
Write 0x7F, 0x00
Write 0x51, 0x7B
Write 0x50, 0x00
Write 0x55, 0x00
Write 0x7F, 0x0E


次に、センサーのキャリブレーション値（C1, C2）を計算し、適用します。

1. レジスタ 0x73 を読み出します。読み出し値が 0x00 でない場合は、以下の計算・書き込み手順をすべてスキップしてください。
2. 読み出し値が 0x00 の場合、以下の手順を実行します。
  1. 現在のC1値をレジスタ 0x70 から、C2値をレジスタ 0x71 から読み出します。
  2. 新しいC1値を計算します:
    * if (C1 <= 28) then new_C1 = C1 + 14
    * else new_C1 = C1 + 11
    * 計算結果は 0x3F を上限とします。
  3. 新しいC2値を計算します: new_C2 = (C2 * 45) / 100
  4. 計算した新しい値を、以下のシーケンスでセンサーに書き込みます。

// Address, Value
Write 0x7F, 0x00
Write 0x61, 0xAD
Write 0x51, <new_C1>  // 上記で計算した新しいC1値
Write 0x7F, 0x0E
Write 0x70, <new_C1>  // 上記で計算した新しいC1値
Write 0x71, <new_C2>  // 上記で計算した新しいC2値


C1/C2の処理が完了したら（またはスキップされたら）、以下のシーケンスを続行します。

// Address, Value
Write 0x7F, 0x00
Write 0x61, 0xAD
Write 0x7F, 0x03
Write 0x40, 0x00
Write 0x7F, 0x05
Write 0x41, 0xB3
Write 0x43, 0xF1
Write 0x45, 0x14
Write 0x5B, 0x32
Write 0x5F, 0x34
Write 0x7B, 0x08
Write 0x7F, 0x06
Write 0x44, 0x1B
Write 0x40, 0xBF
Write 0x4E, 0x3F
Write 0x7F, 0x08
Write 0x65, 0x20
Write 0x6A, 0x18
Write 0x7F, 0x09
Write 0x4F, 0xAF
Write 0x5F, 0x40
Write 0x48, 0x80
Write 0x49, 0x80
Write 0x57, 0x77
Write 0x60, 0x78
Write 0x61, 0x78
Write 0x62, 0x08


ここで 10ms待機します。

待機後、残りのレジスタ設定を書き込みます。

// Address, Value
Write 0x32, 0x44
Write 0x7F, 0x07
Write 0x63, 0x50
Write 0x7F, 0x0A
Write 0x45, 0x60
Write 0x7F, 0x00
Write 0x4D, 0x11
Write 0x55, 0x80
Write 0x74, 0x1F
Write 0x75, 0x1F
Write 0x4A, 0x78
Write 0x4B, 0x78
Write 0x44, 0x08
Write 0x45, 0x50
Write 0x64, 0xFF
Write 0x65, 0x1F
Write 0x7F, 0x14
Write 0x65, 0x67
Write 0x66, 0x08
Write 0x63, 0x70
Write 0x7F, 0x15
Write 0x48, 0x48
Write 0x7F, 0x07
Write 0x41, 0x0D
Write 0x43, 0x14
Write 0x4B, 0x0E
Write 0x45, 0x0F
Write 0x44, 0x42
Write 0x4C, 0x80
Write 0x7F, 0x10
Write 0x5B, 0x02
Write 0x7F, 0x07
Write 0x40, 0x41
Write 0x70, 0x00
Write 0x40, 0x40
Write 0x7F, 0x06
Write 0x62, 0xF0
Write 0x63, 0x00
Write 0x7F, 0x0D
Write 0x48, 0xC0
Write 0x6F, 0xD5
Write 0x7F, 0x00
Write 0x5B, 0xA0
Write 0x4E, 0xA8
Write 0x5A, 0x50
Write 0x40, 0x80


この複雑な初期化シーケンスが完了することで、センサーはモーションデータを正確に生成・報告するための準備が整います。


--------------------------------------------------------------------------------


4.0 モーションデータの読み出し：X-Y変位の取得

初期化と設定が完了したセンサーからは、X軸およびY軸の移動量（変位）を示すモーションデータを取得できます。データ読み出しには、基本的な「標準モード」と、より高速なデータ転送が可能な「バーストモード」の2つの方法があります。

標準的な読み出し手順

標準的な手順では、モーション発生の有無を確認してから、各変位データを個別に読み出します。

1. モーションレジスタの読み出し: まず、Motionレジスタ（アドレス 0x02）を読み出します。この操作により、Delta_X_L/H および Delta_Y_L/H レジスタの値が凍結（ロック）され、読み出し中に値が更新されるのを防ぎます。
2. モーション発生の確認: 読み出したMotionレジスタのビット7がセットされている（1である）ことを確認します。これが1の場合、前回の読み出し以降に何らかの動きがあったことを示します。
3. 変位データの取得: ビット7がセットされていれば、以下のレジスタを順に読み出します。
  * Delta_X_L (アドレス 0x03)
  * Delta_X_H (アドレス 0x04)
  * Delta_Y_L (アドレス 0x05)
  * Delta_Y_H (アドレス 0x06)
4. これらL（下位バイト）とH（上位バイト）を結合することで、それぞれ16ビット符号付き整数としてX変位とY変位を合成します。

高速なバーストモード読み出し

バーストモードは、複数のレジスタデータを一度のSPIトランザクションで連続的に読み出すための効率的な機能です。

* 利点: 各レジスタのアドレスを個別に指定する必要がないため、SPI通信のオーバーヘッドが大幅に削減されます。これにより、MCUの処理負荷を軽減し、より高速なデータサンプリングが可能になります。
* 手順: Motion_Burstレジスタ（アドレス 0x16）に対して読み出し操作を開始することで、バーストモードが起動します。センサーは、以下の12バイトのデータをMISOラインを通じて連続的に返送します。
* 注意点: 12バイトのデータ受信が完了したら、必ずNCSピンを一度Highに戻してください。 これによりバーストモードが終了し、SPIポートがリセットされます。この操作を行わないと、次のSPI通信が正常に行えません。

重要：モーションデータの有効性フィルタリング

PMW3901MBから取得したモーションデータの信頼性を高め、誤ったモーション報告を抑制するためには、以下のフィルタリング処理を適用することが極めて重要です。このルールは、標準モードとバーストモードの両方で取得したデータに適用されるべき普遍的なベストプラクティスです。

* フィルタリング条件: 取得したデータフレームにおいて、SQUALレジスタ（アドレス 0x07）の値が 0x19 未満 かつ Shutter_Upperレジスタ（アドレス 0x0C）の値が 0x1F の場合。
* 処理: 上記の条件に合致する場合、そのフレームで取得した Delta_X と Delta_Y の値は信頼性が低い可能性があるため、破棄することが強く推奨されます。

アプリケーションのリアルタイム性やMCUの処理能力に応じて、標準モードとバーストモードを適切に選択することが重要です。


--------------------------------------------------------------------------------


5.0 結論とベストプラクティス

本ガイドでは、PMW3901MB光学モーションセンサーを組み込みシステムへ実装するための核心的な手順を解説しました。成功の鍵となるベストプラクティスは、以下の3点に集約されます。

* 正確なSPI通信の確立: データシートに規定された書き込み（MSB=1）および読み出し（MSB=0）プロトコルを厳密に遵守することが、全ての操作の基本となります。
* 厳密な初期化シーケンスの実行: 電源投入からパフォーマンス最適化レジスタの設定まで、規定された一連の手順を正しい順序で確実に実行することが、センサーの安定動作と性能を保証します。
* 適切なデータ読み出し方法の選択: システムのリアルタイム性や処理負荷の要件に応じて、個別のレジスタを読み出す標準モードと、効率的な連続読み出しが可能なバーストモードを戦略的に使い分けることが求められます。

このガイドで提供された手順と情報を活用することで、PMW3901MBセンサーを貴社のシステムへ成功裏に統合し、その優れたナビゲーション能力を最大限に引き出すための強固な基盤が構築できると確信しています。
