# ESKFにおけるジャイロバイアス推定の原理

## 1. バイアス推定が可能になる根拠

### 1.1 基本的な考え方

ジャイロバイアスは直接観測できません。しかし、**2つの独立した姿勢情報源**があれば、その差分からバイアスを推定できます。

```
姿勢推定 = ジャイロ積分（バイアス含む） + 加速度計補正（バイアスなし）
```

- **ジャイロ**: 高周波応答が良いが、バイアスがあるとドリフトする
- **加速度計**: 重力方向から絶対姿勢が分かるが、動的加速度に弱い

両者を組み合わせることで、ジャイロのバイアスを推定できます。

### 1.2 観測可能性の条件

バイアス推定が可能になる条件：

1. **静的または準静的な期間がある**: 加速度計が重力方向を正しく測定できる
2. **十分な時間がある**: バイアスの影響がドリフトとして蓄積される
3. **姿勢変化がある**: 異なる姿勢で観測することでバイアスと姿勢誤差を分離

## 2. 数学的メカニズム

### 2.1 状態空間モデル

ESKFの状態ベクトル（15状態）：
```
x = [pos(3), vel(3), att(3), gyro_bias(3), accel_bias(3)]
```

予測ステップの状態遷移：
```
姿勢: θ(k+1) = θ(k) + (ω - b_g) × dt
バイアス: b_g(k+1) = b_g(k)  （ランダムウォークモデル）
```

### 2.2 状態遷移行列 F

姿勢とジャイロバイアスの関係：
```
∂θ/∂b_g = -I × dt
```

これは「バイアスが変化すると、姿勢推定が逆方向に変化する」ことを意味します。

状態遷移行列の該当部分：
```cpp
F_(ATT_X, BG_X) = -dt;
F_(ATT_Y, BG_Y) = -dt;
F_(ATT_Z, BG_Z) = -dt;
```

### 2.3 観測更新によるバイアス推定

加速度計姿勢補正の観測モデル：
```
z = [accel_x, accel_y]  // 測定値
h = [g×pitch, -g×roll]  // 予測値（小角近似）
```

ヤコビアン H：
```
H = [0 0 0 | 0 0 0 | 0 +g 0 | 0 0 0 | 0 0 0]  // accel_x → pitch
    [0 0 0 | 0 0 0 | -g 0 0 | 0 0 0 | 0 0 0]  // accel_y → roll
```

**重要**: Hは直接バイアスを観測していません（バイアス列は0）。

### 2.4 共分散伝播によるバイアス推定

カルマンゲイン計算：
```
K = P × H^T × (H × P × H^T + R)^(-1)
```

共分散行列Pには、予測ステップで蓄積された姿勢-バイアス間の相関が含まれます：
```
P_θ,bg ≠ 0  （姿勢とバイアスの相関）
```

この相関により、姿勢の観測更新がバイアス推定にも波及します：

```
状態更新: dx = K × (z - h)

dx_θ  = K_θ × innovation      // 姿勢補正
dx_bg = K_bg × innovation     // バイアス補正（間接的）
```

## 3. バイアス推定の物理的解釈

### 3.1 正常なバイアス推定

```
時刻t1: 加速度計「ロール0°」、ジャイロ積分「ロール5°」
        → 差分5°は何かのせい

時刻t2: 同じ差分が続く
        → 一定のオフセット = バイアスと判断

時刻t3: バイアス推定値を更新
        → ジャイロ - バイアス = 正しい姿勢
```

### 3.2 推定が成立する条件

| 条件 | 説明 |
|------|------|
| 静止時間 | 加速度計が正しい参照を提供 |
| 一貫した誤差 | ランダムノイズではなく系統的なオフセット |
| 時間経過 | バイアスの影響が蓄積して検出可能に |

## 4. 現在の問題：ロール動揺時のバイアス誤推定

### 4.1 問題の状況

flow01.binテスト：
- 機体を手で持ち、ロール軸周りに±30°で動揺
- 並進移動なし、定点で振動

観測結果：
```
純粋ジャイロ積分:  -0.74°  (正しい、元の姿勢に戻っている)
推定バイアスX:     -15.25 mrad/s  (誤り、真値は約0)
ESKFロール:        +25.34°  (大きくドリフト)
```

### 4.2 誤推定のメカニズム

1. **ロール動揺中、加速度計は正しく傾きを検出**
   - 右に30°傾く → accel_y ≈ +4.9 m/s²
   - 左に30°傾く → accel_y ≈ -4.9 m/s²

2. **しかし、加速度計更新とジャイロ積分に位相差がある**
   - ジャイロ積分は連続的
   - 加速度計更新は離散的（50Hz）
   - 高速振動時、サンプリング時点での姿勢と積分値にずれ

3. **このずれが「バイアス」として解釈される**
   ```
   イノベーション = accel観測 - ジャイロ予測
                 = 正しい姿勢 - (少しずれた姿勢)
                 = 系統的な誤差パターン
   ```

4. **カルマンフィルタはこれをバイアスと誤認**
   - 誤差が一方向に偏ると、バイアスとして吸収しようとする
   - 振動の非対称性や位相遅れが「定常的なバイアス」に見える

### 4.3 図解

```
時間 →
        ___     ___
       /   \   /   \
実際の姿勢:  \_____/   \_____/  (振動、平均=0)

        ___     ___
       /   \   /   \
ジャイロ積分: \_____/   \_____/  (正確に追従)

      |     |     |     |
加速度更新:  ↓     ↓     ↓     ↓  (離散サンプリング)

サンプル時点での差分:
  → 位相差により一方向に偏った誤差パターン
  → フィルタ「これはバイアスだ」と誤認
```

## 5. 対策の方向性

### 5.1 根本原因に基づく対策

| 対策 | 原理 | 効果 |
|------|------|------|
| 高回転時はバイアス更新を抑制 | 動揺中の誤情報を使わない | バイアスドリフト防止 |
| gyro_bias_noiseを増加 | バイアス推定の時定数を短くする | 誤推定が蓄積しにくい |
| 姿勢→バイアスの結合を弱める | P行列の相関項を制限 | 姿勢誤差がバイアスに波及しない |

### 5.2 推奨アプローチ

**高回転時のバイアス更新抑制**が最も論理的：

```cpp
void ESKF::updateAccelAttitudeWithGyro(const Vector3& accel, const Vector3& gyro)
{
    // 高回転時はバイアス推定を保護
    float gyro_mag = std::sqrt(gyro.x*gyro.x + gyro.y*gyro.y);

    if (gyro_mag > threshold) {
        // 方法1: 更新自体をスキップ
        // 方法2: バイアス状態の共分散を保護
        // 方法3: カルマンゲインのバイアス成分を0に
    }
}
```

理由：
- 静止時・低速時はバイアス推定が正しく機能
- 高回転時のみ保護することで、通常動作に影響なし
- 物理的に正当な判断（高回転時の加速度計は信頼性低下）

## 6. 補足：バイアス推定のQ値の役割

### 6.1 gyro_bias_noiseの意味

```cpp
Q_(BG_X, BG_X) = gyro_bias_noise² × dt
```

これは「バイアスがどれだけ変動するか」のモデルです。

- **小さい値**: バイアスは安定、推定を信頼 → ゆっくり更新
- **大きい値**: バイアスは不安定 → 素早く追従するが不安定

### 6.2 現在の設定

```cpp
cfg.gyro_bias_noise = 0.00005f;  // rad/s/√s
```

この値は非常に小さく、「バイアスは非常に安定」というモデルです。
そのため、一度誤ったバイアスを推定すると長時間維持されます。

## 7. 対策案の詳細比較

### 案1: 高回転時のバイアス更新抑制

**原理**: 問題が発生する条件（高回転）を検出し、その間だけバイアス推定を停止

```cpp
if (gyro_magnitude > threshold) {
    // バイアス更新をスキップまたは抑制
}
```

**メリット**:
- 問題の根本原因に直接対処
- 静止時のバイアス推定精度を維持
- 論理的に明確

**デメリット**:
- 閾値の設定が必要
- 長時間の高回転中に真のバイアスが変化した場合に追従できない

---

### 案2: プロセスノイズ（gyro_bias_noise）の増加

**原理**: バイアスの「時定数」を短くして、誤推定の蓄積を防ぐ

```cpp
// 現在値
cfg.gyro_bias_noise = 0.00005f;  // 非常に安定と仮定

// 増加案
cfg.gyro_bias_noise = 0.001f;    // より不安定と仮定
```

**数学的効果**:

プロセスノイズQが大きい → 共分散Pの成長が速い → カルマンゲインKが大きい

しかし同時に：
- バイアス推定の「記憶」が短くなる
- 新しい観測により強く反応する
- 誤推定も素早く修正される

**時定数の概念**:
```
τ ≈ 1 / (gyro_bias_noise² × 観測頻度)

現在: τ ≈ 非常に長い（誤推定が長時間持続）
増加後: τ ≈ 短い（誤推定も素早く忘れる）
```

**メリット**:
- 実装変更が最小限（パラメータ変更のみ）
- 誤推定が蓄積しにくい
- 静止時も動的時も同じロジック

**デメリット**:
- 静止時のバイアス推定精度も低下する
- 真のバイアスへの収束が遅くなる
- 最適値の決定が難しい（トレードオフ）

---

### 案1 vs 案2 の比較表

| 観点 | 案1: 高回転抑制 | 案2: プロセスノイズ増加 |
|------|----------------|----------------------|
| 実装複雑度 | 中（条件分岐追加） | 低（パラメータ変更） |
| 静止時の精度 | 維持 | 低下 |
| 動的時の安定性 | 高 | 中 |
| パラメータ調整 | 閾値1つ | ノイズ値1つ |
| 物理的妥当性 | 高（原因に直接対処） | 中（間接的対処） |
| 副作用 | 少ない | バイアス推定全体に影響 |

---

### 案2の定量的検討

現在の設定での時定数を計算：

```
gyro_bias_noise = 0.00005 rad/s/√s
観測更新頻度 = 50 Hz
dt = 0.02 s

Q_bias = (0.00005)² × 0.02 = 5×10⁻¹¹ rad²/s²

これは非常に小さく、バイアス推定が「ほぼ固定」に近い動作
```

gyro_bias_noiseを増加させた場合：

| gyro_bias_noise | 相対的な時定数 | 予想される動作 |
|-----------------|---------------|---------------|
| 0.00005 (現在) | 1.0 | 誤推定が長時間持続 |
| 0.0001 | 0.25 | やや改善 |
| 0.0005 | 0.01 | 大幅に改善、ただし不安定化リスク |
| 0.001 | 0.0025 | 過敏、ノイズに弱い |

---

### 推奨: 両案の組み合わせ

最も堅牢なアプローチは両案の併用：

```cpp
// 案2: プロセスノイズを適度に増加（0.0001〜0.0005）
cfg.gyro_bias_noise = 0.0002f;

// 案1: 高回転時はさらに抑制
if (gyro_magnitude > threshold) {
    // バイアスのカルマンゲインを減衰
    K_bias *= decay_factor;
}
```

これにより：
- 通常時: 適度なバイアス推定（案2の効果）
- 高回転時: 追加の保護（案1の効果）

## 8. 先行研究と実用システムでの対策

### 8.1 位相遅れについて

**重要な認識**: 積分による90°位相遅れは信号処理上の位相シフトであり、正しく積分すれば値自体は一致します。

```
ω(t) = Aω cos(ωt)  →  ∫ω dt = A sin(ωt) = θ(t)
```

問題は**離散積分誤差**と**サンプリングタイミング**です。

### 8.2 先行研究の知見

#### 観測可能性条件
[MDPI Sensors (2011)](https://www.mdpi.com/1424-8220/11/10/9182) によると：
- ジャイロバイアス推定には**角運動が必要**（我々のテストでは満たしている）
- 加速度バイアスは直進運動では観測不能（姿勢誤差と分離できない）
- 磁場と重力が非平行であることが条件

#### カスケードフィルタ
[IEEE (2020)](https://ieeexplore.ieee.org/document/9032181/) の手法：
- 2つのカルマンフィルタを連結
- 第1フィルタ: 姿勢と外部加速度を推定
- 第2フィルタ: ジャイロバイアスを推定
- **高ダイナミクス時の分離**が目的

#### 適応的手法
[Wiley (2016)](https://onlinelibrary.wiley.com/doi/10.1155/2016/6943040) によると：
- 動的時の姿勢推定誤差は外部加速度が原因
- **測定ノイズ共分散Rを動的に調整**して補償
- 適応パラメータで動的条件を検出

#### 実用システム (ArduPilot)
[ArduPilot EKF Documentation](https://ardupilot.org/dev/docs/extended-kalman-filter.html) より：
- `EKF_GYRO_NOISE`: ジャイロバイアス状態誤差の成長を制御
- **増加させると**バイアス推定が速くノイジーになる
- 温度変化によるバイアスドリフトに対応

#### 適応型UKF
[ScienceDirect (2024)](https://www.sciencedirect.com/science/article/abs/pii/S0888327024007684) の手法：
- ファジー論理による適応的フィルタリング
- ジャイロバイアスを状態に含め高周波フィードバック補償
- 強い追跡フィルタ(STF)との組み合わせ

### 8.3 実用的アプローチのまとめ

| 手法 | 使用例 | 特徴 |
|------|--------|------|
| 適応的R | Madgwick, Mahony | 動的検出→観測信頼度調整 |
| プロセスノイズ調整 | ArduPilot | gyro_bias_noiseで時定数制御 |
| カスケードフィルタ | 航空宇宙 | 姿勢とバイアスを分離推定 |
| 補完フィルタ | 多くのドローン | 周波数領域での分離 |

### 8.4 本プロジェクトへの示唆

1. **案1（高回転時抑制）**: カスケードフィルタの簡易版と考えられる
2. **案2（プロセスノイズ）**: ArduPilotと同様のアプローチ
3. 両案とも先行研究で有効性が確認されている

## 9. 実験結果と採用対策

### 9.1 案1（高回転時抑制）の実験結果

**結果: 効果なし**

高回転時（gyro > 0.5 rad/s）にバイアス更新を抑制する対策を実装・テストしたが、
動揺後のロール/ピッチドリフト問題は解消されなかった。

考えられる理由:
- 高回転と低回転の境界での不連続性
- 閾値以下でも位相差による誤推定が蓄積
- 400Hz更新により短時間でもバイアスが変動

### 9.2 採用対策: accel_bias_noiseの調整

**案2（プロセスノイズ増加）を採用**

```cpp
// 変更前（姿勢発散防止で設定）
accel_bias_noise = 0.0001f;  // バイアス推定が非常に遅い

// 変更後
accel_bias_noise = 0.001f;   // 誤推定からの回復を速くする
```

トレードオフ:
- メリット: 動揺後のバイアス誤推定が速く修正される
- デメリット: 静止時のバイアス推定精度がやや低下

## 10. まとめ

1. **バイアス推定の原理**: 加速度計（絶対姿勢）とジャイロ積分（相対姿勢）の差分からバイアスを推定

2. **正常動作の条件**: 静止または低速時に加速度計が正しい参照を提供

3. **問題と対策履歴**:
   - 問題: 高速動揺時、位相差により生じる誤差パターンがバイアスと誤認される
   - 案1（高回転時抑制）: 実装・テスト済み → **効果なし**
   - 案2（プロセスノイズ増加）: **採用** (accel_bias_noise = 0.001)
