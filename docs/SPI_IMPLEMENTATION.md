# SPI バス設計と実装

## SPI2_HOST 共有バス構成

BMI270（IMU）とPMW3901（OpticalFlow）が同一SPIバスを共有:

| デバイス | CS | 用途 | 転送頻度 |
|----------|-----|------|----------|
| BMI270 | GPIO39 | 加速度・角速度 | 400Hz |
| PMW3901 | GPIO12 | オプティカルフロー | 100Hz |

## 解決済みの問題

**問題**: `spi_device_polling_transmit`（BMI270）と`spi_device_transmit`（PMW3901）の混在により、ESP-IDF SPI ドライバ内部でバスロック競合が発生し、タスクが停止。

**解決**: 全デバイスを`spi_device_polling_transmit`に統一（2024-12実装）

---

## なぜポーリングと割り込みの混在でバスロックが発生するのか

### ESP-IDF SPI ドライバの2つの転送モード

```
┌─────────────────────────────────────────────────────────────┐
│ spi_device_polling_transmit（ポーリングモード）            │
├─────────────────────────────────────────────────────────────┤
│ 1. バスロック取得                                          │
│ 2. CS Low                                                   │
│ 3. データ送受信（CPUがビジーウェイト）                     │
│ 4. CS High                                                  │
│ 5. バスロック解放                                          │
│                                                             │
│ 特徴: 関数呼び出し中、CPUは他のことをしない               │
│       転送完了まで関数から戻らない                         │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ spi_device_transmit（割り込みモード）                       │
├─────────────────────────────────────────────────────────────┤
│ 1. トランザクションをキューに追加                          │
│ 2. バスロック取得（キュー処理開始時）                      │
│ 3. CS Low                                                   │
│ 4. データ送受信開始（DMA/割り込み）                        │
│ 5. タスクはスリープ（CPU解放）  ← ここが違う！            │
│ 6. 転送完了割り込み発生                                    │
│ 7. CS High                                                  │
│ 8. バスロック解放                                          │
│ 9. タスク起床、関数から戻る                                │
│                                                             │
│ 特徴: 転送中にCPUは他タスクを実行可能                      │
│       内部でFreeRTOSセマフォを使用                         │
└─────────────────────────────────────────────────────────────┘
```

### 問題が発生するシナリオ

```
時間 →
────────────────────────────────────────────────────────────────

OptFlowTask (優先度20):
    │
    ▼
┌─────────────────────────────────────────┐
│ spi_device_transmit() 開始              │
│   1. キューに追加                       │
│   2. バスロック取得 ✓                   │
│   3. CS Low                             │
│   4. DMA転送開始...                     │
│   5. タスクスリープ（転送完了待ち）     │ ← この瞬間！
└─────────────────────────────────────────┘
         │
         │ スケジューラが高優先度タスクに切り替え
         ▼
────────────────────────────────────────────────────────────────

IMUTask (優先度24):  ← 優先度が高いので実行権を得る
    │
    ▼
┌─────────────────────────────────────────┐
│ spi_device_polling_transmit() 開始      │
│   1. バスロック取得を試みる...          │
│      → OptFlowTaskが持っている！        │
│      → 待機... 待機... 待機...          │ ← 永久に待機
│                                          │
│   ★ デッドロック発生 ★                  │
│                                          │
│   OptFlowTaskはIMUTaskより低優先度      │
│   → 実行権を得られない                  │
│   → 転送完了割り込みを処理できない      │
│   → バスロックを解放できない            │
│                                          │
│   IMUTaskはバスロック待ち               │
│   → 永久にブロック                      │
└─────────────────────────────────────────┘

結果: 両タスクとも停止
```

### 問題の本質: 優先度逆転

```
┌─────────────────────────────────────────────────────────────┐
│                     優先度逆転とは                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  通常の期待:                                                │
│    高優先度タスク → 低優先度タスクより先に実行される       │
│                                                             │
│  優先度逆転:                                                │
│    低優先度タスクがリソース（バスロック）を持ったまま      │
│    スリープすると、高優先度タスクがそのリソースを          │
│    待ち続けて実行できなくなる                              │
│                                                             │
│    低優先度タスクは、高優先度タスクがCPUを占有している    │
│    ため実行されず、リソースを解放できない                  │
│                                                             │
│    → 相互に待ち合い → デッドロック                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### なぜポーリング統一で解決するのか

```
ポーリングモード統一後:

OptFlowTask:
    │
    ▼
┌─────────────────────────────────────────┐
│ spi_device_polling_transmit()           │
│   1. バスロック取得 ✓                   │
│   2. CS Low                             │
│   3. データ送受信（CPU占有）            │
│   4. CS High                            │
│   5. バスロック解放 ✓                   │ ← 必ずここまで完了
└─────────────────────────────────────────┘
    │
    │ 関数から戻った後にスケジューラ切り替え
    ▼

IMUTask:
    │
    ▼
┌─────────────────────────────────────────┐
│ spi_device_polling_transmit()           │
│   1. バスロック取得 ✓  ← 空いている！   │
│   2. CS Low                             │
│   3. データ送受信                       │
│   4. CS High                            │
│   5. バスロック解放 ✓                   │
└─────────────────────────────────────────┘

ポイント:
- ポーリングモードはアトミック（途中で中断されない）
- バスロックを持ったままスリープしない
- 転送完了まで関数から戻らない
- 優先度逆転が発生しない
```

### 割り込みモード統一でも解決可能

```
割り込みモード統一の場合:

両タスクが spi_device_transmit() を使用:
  → 内部キューで順序管理される
  → ドライバが適切にバスロックを管理
  → 優先度逆転防止機構（優先度継承）が機能

ただし:
  - 割り込みオーバーヘッドがある
  - 短い転送（14バイト等）では非効率
  - 本プロジェクトではポーリング統一を選択
```

### まとめ

| 構成 | 動作 | 問題 |
|------|------|------|
| ポーリング + 割り込み混在 | ❌ | 優先度逆転でデッドロック |
| ポーリングのみ | ✅ | アトミック動作で安全 |
| 割り込みのみ | ✅ | キュー管理で安全 |

**教訓**: 同一SPIバスを共有する複数デバイスは、同一の転送モードに統一すること

## 現在の転送方式

| 関数 | サイズ | バッファ | 用途 |
|------|--------|----------|------|
| `bmi270_read_burst` ≤32B | スタック | 通常IMU読み取り(14B) |
| `bmi270_read_burst` >32B | DMA(malloc) | FIFO読み取り(最大2KB) |
| `bmi270_write_burst` ≤32B | スタック | レジスタ書き込み |
| `bmi270_write_burst` >32B | DMA(malloc) | config file(8KB) |
| `pmw3901_*` | スタック | 全て32B以下 |

**32バイト閾値の理由**: ESP-IDF SPIドライバは32バイト以下でCPU転送、超過でDMA転送を使用

## 今後の実装計画

### Phase 1: SPI統一（完了 ✅）
- [x] PMW3901を`spi_device_polling_transmit`に変更
- [x] BMI270バッファ最適化（小転送はスタック）
- [x] 長時間動作テスト（10分以上）→ 成功

### Phase 2: オーバーサンプリング対応
BMI270を高ODRで動作させ、FIFOで複数サンプルを一括取得:

```
BMI270: 1600Hz ODR
    ↓ FIFO (4 frames蓄積)
    ↓ Watermark割り込み (400Hz)
IMUTask: 4サンプル読み取り → フィルタ → ESKF
```

- [ ] BMI270 FIFO設定変更（ODR=1600Hz, watermark=4 frames）
- [ ] 割り込みハンドラ調整（Data Ready → FIFO Watermark）
- [ ] フィルタ処理統合

### Phase 3: フィルタコンポーネント
`stampfly_filter`コンポーネント新規作成:

- [ ] LPF（Butterworth等）実装
- [ ] ノッチフィルタ（モーター振動除去）
- [ ] 将来: 適応フィルタ（RPM連動ダイナミックノッチ）

### Phase 4: 非接触回転計測（将来）
加速度FFT解析によるモーターRPM推定:

- BPF (Blade Passing Frequency) = RPM × ブレード枚数 / 60
- esp-dspライブラリでFFT実行
- ESCテレメトリ不要の回転数取得

## BMI270 ODR仕様

| センサー | 最大ODR | レジスタ値 |
|----------|---------|------------|
| 加速度計 | 1600Hz | 0x0C |
| ジャイロスコープ | 3200Hz | 0x0D |

ジャイロは加速度の2倍の最大ODRをサポート。
FIFO使用時は両者同一ODRが推奨（フレーム解析が単純）。

## 関連ファイル

- `components/stampfly_imu/src/bmi270_spi.c` - BMI270 SPI転送実装
- `components/stampfly_opticalflow/src/pmw3901.c` - PMW3901 SPI転送実装
- `components/stampfly_imu/CLAUDE.md` - BMI270ドライバ詳細
- `components/stampfly_opticalflow/CLAUDE.md` - PMW3901ドライバ詳細
