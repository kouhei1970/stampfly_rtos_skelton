# PID制御 技術ドキュメント

本ドキュメントは、StampFlyプロジェクトで採用するPID制御器の理論と実装について解説します。

---

## 1. PID制御の基本

### 1.1 PID制御とは

PID制御は、目標値と現在値の**偏差**に基づいて制御入力を決定するフィードバック制御です。

```
目標値 r(t) ──(+)──> [偏差 e(t)] ──> [PID制御器] ──> 制御入力 u(t) ──> [プラント] ──> 出力 y(t)
              (-)                                                              │
               └──────────────────────────────────────────────────────────────┘
```

偏差: `e(t) = r(t) - y(t)`

### 1.2 P・I・D 各要素の役割

| 要素 | 作用 | 効果 | 過剰な場合 |
|------|------|------|-----------|
| **P** (比例) | 偏差に比例した出力 | 応答速度向上 | 振動・不安定化 |
| **I** (積分) | 偏差の累積に比例 | 定常偏差の除去 | オーバーシュート・ワインドアップ |
| **D** (微分) | 偏差の変化率に比例 | 振動抑制・応答改善 | ノイズ増幅 |

### 1.3 理想PIDの伝達関数

理想的なPID制御器の伝達関数:

```
C(s) = Kp + Ki/s + Kd·s
     = Kp(1 + 1/(Ti·s) + Td·s)
```

ここで:
- `Kp`: 比例ゲイン
- `Ki = Kp/Ti`: 積分ゲイン
- `Kd = Kp·Td`: 微分ゲイン
- `Ti`: 積分時間
- `Td`: 微分時間

### 1.4 積分時間・微分時間の物理的意味

Ti と Td は一見わかりにくい用語だが、周波数特性で理解すると明確になる。

#### 積分時間 Ti

**定義**: 積分項が比例項と同じ大きさになる時間

ステップ偏差を考える:
```
時刻 t=0 で偏差 e が発生し、一定値を維持
- 比例項: P = Kp · e（即座に一定値）
- 積分項: I = (Kp/Ti) · e · t（時間とともに増加）

t = Ti のとき: I = Kp · e = P
```

**周波数領域での意味**:
```
積分項: Kp/(Ti·s)
ω = 1/Ti で |積分項| = |比例項|
```

- **Ti が小さい** → 積分が強い → 定常偏差を速く除去 → オーバーシュート増加
- **Ti が大きい** → 積分が弱い → 定常偏差の除去が遅い → 安定

#### 微分時間 Td

**定義**: 微分項が比例項と同じ大きさになる偏差の変化率の逆数

ランプ状の偏差 e(t) = a·t を考える:
```
- 比例項: P = Kp · a · t
- 微分項: D = Kp · Td · a（一定値）

t = Td のとき: P = Kp · a · Td = D
```

**周波数領域での意味**:
```
微分項: Kp · Td · s
ω = 1/Td で |微分項| = |比例項|
```

- **Td が小さい** → 微分が弱い → 位相進み効果小さい
- **Td が大きい** → 微分が強い → 位相進み効果大きい → ノイズ敏感

#### Ti と Td の関係

経験則として:
```
Td ≈ Ti/4 〜 Ti/8
```

これは微分の位相進み効果が積分の位相遅れを適切に補償する範囲。

**問題点**: 純粋な微分 `Kd·s` は高周波ノイズを無限大に増幅する（実装不可能）。

---

## 2. 不完全微分付きPID制御器

### 2.1 本プロジェクトで採用する形式

純粋微分の問題を解決するため、**不完全微分**（ローパスフィルタ付き微分）を使用:

```
C(s) = Kp(1 + 1/(Ti·s) + Td·s/(η·Td·s + 1))
```

ここで:
- `η`: フィルタ係数（通常 0.1〜0.2）

### 2.2 不完全微分の効果

微分項の周波数応答:

```
純粋微分:     |D(jω)| = Kd·ω        → ω→∞ で無限大
不完全微分:   |D(jω)| ≈ Kd/η (ω→∞) → 高周波でゲイン飽和
```

```
ゲイン
  │         ── 純粋微分（実装不可）
  │        /
  │       /  ┌─── 不完全微分（実用）
  │      / ─┘
  │     /
  │    /
  │   /
  │──/─────────────────────> 周波数
        ↑
    1/(η·Td) = カットオフ周波数
```

`η`が小さいほど純粋微分に近づくが、ノイズ耐性が低下。

### 2.3 η の選び方

| η | 特性 | 用途 |
|---|------|------|
| 0.05〜0.1 | 微分効果強い、ノイズ敏感 | ノイズの少ないシステム |
| 0.1〜0.2 | バランス型（推奨） | 一般的なアプリケーション |
| 0.2〜0.5 | ノイズ耐性高い、微分効果弱い | ノイズの多いシステム |

---

## 3. 離散化

### 3.1 双一次変換（Tustin変換）

連続時間システムを離散時間に変換する際、双一次変換を使用:

```
s → (2/T)·(z-1)/(z+1)
```

ここで `T` はサンプリング周期。

### 3.2 なぜ個別に離散化するのか

**重要**: PID全体を一括で双一次変換してはいけない。

理由:
```
C(s) = Kp(1 + 1/(Ti·s) + Td·s/(η·Td·s + 1))
```

一括変換すると、積分と微分の離散化誤差が**相殺**され、本来の周波数特性が失われる。

**正しい方法**: 各要素を個別に離散化してから組み合わせる。

### 3.3 積分要素の離散化

連続: `I(s) = 1/(Ti·s)`

双一次変換:
```
s → (2/T)·(z-1)/(z+1)

I(z) = T(z+1) / (2·Ti·(z-1))
```

差分方程式:
```
I[k] = I[k-1] + (T/(2·Ti))·(e[k] + e[k-1])
```

これは**台形積分**に相当。

### 3.4 不完全微分の離散化

連続: `D(s) = Td·s / (η·Td·s + 1)`

双一次変換後:
```
D(z) = (2·Td/T)·(z-1) / ((2·η·Td/T + 1)·z + (1 - 2·η·Td/T))
```

簡略化のため、係数を定義:
```
α = 2·η·Td / T
a = (α - 1) / (α + 1)
b = Td / ((α + 1)·T/2)  = 2·Td / ((α + 1)·T)
```

差分方程式:
```
D[k] = -a·D[k-1] + b·(e[k] - e[k-1])
```

ここで `a` と `b` は事前計算可能な定数。

---

## 4. アンチワインドアップ

### 4.1 ワインドアップ問題

積分項は偏差を累積するため、アクチュエータが**飽和**した状態で偏差が残ると、積分値が際限なく増加（ワインドアップ）。

飽和解除後、過大な積分値により:
- 大きなオーバーシュート
- 応答遅延
- 振動

### 4.2 方式1: 条件付き積分（Conditional Integration）

**方式**: 出力が飽和しているとき、積分を停止。

```cpp
if (output_saturated && sign(error) == sign(integral)) {
    // 飽和方向に積分が進む場合は積分停止
} else {
    integral += (T / (2 * Ti)) * (error + prev_error);
}
```

シンプルだが、飽和解除時の応答が遅い場合がある。

### 4.3 方式2: バックキャリキュレーション（Back-calculation）【推奨】

**方式**: 出力飽和量を積分にフィードバックし、積分値を適切な範囲に維持。

```cpp
// 1. 通常の積分更新
integral += (T / (2 * Ti)) * (error + prev_error);

// 2. 出力計算
float output_unlimited = proportional + integral + derivative;
float output = clamp(output_unlimited, output_min, output_max);

// 3. 飽和量のフィードバック
float saturation = output - output_unlimited;
integral += saturation * (T / Tt);  // Tt: トラッキング時定数
```

**トラッキング時定数 Tt の選び方:**
- `Tt = sqrt(Ti * Td)`: 一般的な推奨値
- `Tt = Ti`: 保守的（ゆっくり戻る）
- `Tt < Ti`: 積極的（速く戻る）

**利点:**
- 飽和中も積分値が適切な範囲に維持される
- 飽和解除時にスムーズに通常動作に復帰
- 理論的に裏付けのある方法

### 4.4 本プロジェクトの選択

**バックキャリキュレーション方式**を採用。理論的根拠が明確で、飽和からの復帰特性が優れている。

---

## 5. 微分先行型PID（D-on-M）

### 5.1 標準形式の問題

標準PID（D-on-E: Derivative on Error）:
```
D項 = Kd · d(e)/dt = Kd · d(r - y)/dt
```

目標値 `r` がステップ状に変化すると、微分項に**スパイク**が発生。

### 5.2 微分先行型（D-on-M: Derivative on Measurement）

目標値を微分から除外:
```
D項 = -Kd · d(y)/dt
```

効果:
- 目標値変化時のスパイク除去
- スムーズな応答
- 入力トルクの低減

### 5.3 比較

| 方式 | 微分対象 | 目標値ステップ応答 | 用途 |
|------|----------|-------------------|------|
| D-on-E | 偏差 e = r - y | スパイク発生 | 素早い追従が必要 |
| D-on-M | 測定値 y のみ | スムーズ | 滑らかな動作が必要 |

ドローンの角速度制御では**D-on-M**が一般的（モーターへの急激な指令を避ける）。

### 5.4 実装

```cpp
if (derivative_on_measurement) {
    // D-on-M: 測定値の変化を微分
    derivative = compute_derivative(-measurement);
} else {
    // D-on-E: 偏差を微分
    derivative = compute_derivative(error);
}
```

---

## 6. 実装まとめ

### 6.1 パラメータ

| パラメータ | 記号 | 説明 | 典型値 |
|-----------|------|------|--------|
| 比例ゲイン | Kp | 応答速度を決定 | システム依存 |
| 積分時間 | Ti | 積分効果の時定数 | システム依存 |
| 微分時間 | Td | 微分効果の時定数 | 0〜Ti/4程度 |
| フィルタ係数 | η | 微分のローパス | 0.1〜0.2 |
| サンプリング周期 | T | 離散化周期 | 1/400 = 2.5ms |

### 6.2 計算順序

```cpp
float PID::update(float setpoint, float measurement, float dt) {
    // 1. 偏差計算
    float error = setpoint - measurement;

    // 2. 比例項
    float P = Kp_ * error;

    // 3. 積分項（台形積分 + アンチワインドアップ）
    float I = update_integral(error, dt);

    // 4. 微分項（不完全微分、D-on-E or D-on-M選択）
    float D = update_derivative(error, measurement, dt);

    // 5. 出力合成
    float output = P + I + D;

    // 6. 出力制限
    output = clamp(output, output_min_, output_max_);

    // 7. 状態更新
    prev_error_ = error;
    prev_measurement_ = measurement;

    return output;
}
```

### 6.3 内部状態

| 状態変数 | 用途 |
|----------|------|
| `integral_` | 積分項の累積値 |
| `derivative_filtered_` | フィルタ済み微分項 |
| `prev_error_` | 前回の偏差（積分用） |
| `prev_measurement_` | 前回の測定値（D-on-M用） |

---

## 7. 実装API（案）

```cpp
class PID {
public:
    struct Config {
        float Kp = 1.0f;           // 比例ゲイン
        float Ti = 1.0f;           // 積分時間 [s]（0 or 負で積分無効）
        float Td = 0.0f;           // 微分時間 [s]（0 or 負で微分無効）
        float eta = 0.1f;          // 不完全微分フィルタ係数
        float Tt = 0.0f;           // トラッキング時定数（0でsqrt(Ti*Td)を使用）
        float output_min = -1.0f;  // 出力下限
        float output_max = 1.0f;   // 出力上限
        bool derivative_on_measurement = true;  // D-on-M
    };

    void init(const Config& config, float dt);
    float update(float setpoint, float measurement);
    void reset();

    // ゲイン動的変更
    void setKp(float kp);
    void setTi(float ti);
    void setTd(float td);

    // デバッグ用
    float getProportional() const;
    float getIntegral() const;
    float getDerivative() const;
};
```

---

## 8. チューニング指針

### 8.1 周波数領域でのチューニング【推奨】

PIDパラメータの設計は、**ゲイン交差周波数**と**位相余裕**を意識することで、帯域と安定性を両立できる。

#### 基本概念

| 用語 | 定義 | 意味 |
|------|------|------|
| ゲイン交差周波数 ωc | \|L(jωc)\| = 1 となる周波数 | ≈ 閉ループ帯域 |
| 位相余裕 PM | 180° + ∠L(jωc) | 安定余裕の指標 |
| ゲイン余裕 GM | 1 / \|L(jω180)\| | 位相が-180°での余裕 |

ここで L(s) は開ループ伝達関数。

#### 推奨値

| パラメータ | 推奨値 | 備考 |
|-----------|--------|------|
| 位相余裕 | **60°程度** | 40°未満は振動的、70°以上は応答遅い |
| ゲイン余裕 | 6dB以上 | 2倍以上の余裕 |

経験的に、位相余裕60°程度を確保しないと実システムでの安定性確保が難しい場合が多い。

#### 帯域の見積もり（第一原理）

ドローンの角速度制御の帯域は以下で制限される:

1. **機体ダイナミクス**: 慣性モーメントとトルク
2. **アクチュエータ応答**: モーター+プロペラの時定数
3. **サンプリング周波数**: 制御周期による制限
4. **センサノイズ**: 高帯域にするとノイズが乗る

#### ドローンの運動方程式

角速度制御のプラントは:
```
J · dω/dt = τ

伝達関数: G(s) = ω(s)/τ(s) = 1/(J·s)
```

ここで:
- `J`: 慣性モーメント [kg·m²]
- `ω`: 角速度 [rad/s]
- `τ`: トルク [N·m]

純粋な積分特性なので、比例制御だけで安定化可能（1型システム）。

#### StampFlyの慣性モーメント推定

**機体スペック:**
- 対角長: 65mm（アーム長 ≈ 32.5mm）
- 総重量: 37g
- モーター: φ7mm × 16mm コアレスモーター（約3g/個）
- バッテリ: 前後中心線上、下部に細長く配置

**簡易推定（集中質量モデル）:**

Roll/Pitch軸の慣性モーメント:
```
モーター4個（各3g、半径32.5mm）:
  Jm = 4 × 0.003 × 0.0325² = 1.27 × 10⁻⁵ kg·m²

バッテリ（約15g、中心配置、回転軸から10mm程度）:
  Jb ≈ 0.015 × 0.01² = 1.5 × 10⁻⁶ kg·m²

フレーム等（約10g、分布）:
  Jf ≈ 0.010 × 0.02² = 4 × 10⁻⁶ kg·m²

合計: J_roll ≈ 1.8 × 10⁻⁵ kg·m²
```

Yaw軸の慣性モーメント:
```
モーター4個（各3g、半径32.5mm）:
  Jm = 4 × 0.003 × 0.0325² = 1.27 × 10⁻⁵ kg·m²

バッテリ（前後に細長い → Yaw軸周りは小さい）:
  Jb ≈ 0.015 × 0.005² = 0.4 × 10⁻⁶ kg·m²

合計: J_yaw ≈ 1.3 × 10⁻⁵ kg·m²
```

**推定値まとめ:**

| 軸 | 慣性モーメント J |
|----|-----------------|
| Roll | ≈ 1.8 × 10⁻⁵ kg·m² |
| Pitch | ≈ 1.8 × 10⁻⁵ kg·m² |
| Yaw | ≈ 1.3 × 10⁻⁵ kg·m² |

#### 帯域の制約要因

1. **アクチュエータ応答**
   - コアレスモーター: τm ≈ 20〜30ms（ブラシレスより遅い）
   - 帯域上限: ωm ≈ 1/τm ≈ 30〜50 rad/s

2. **サンプリング周波数**
   - 制御周期 T = 2.5ms (400Hz)
   - 実用上: ωc < ωs/10 ≈ 250 rad/s（十分余裕あり）

3. **センサノイズ**
   - BMI270ジャイロ: ノイズ密度 ≈ 0.008 °/s/√Hz
   - 高帯域にするとノイズが増幅される

**StampFlyの推奨帯域:**
```
制限要因: モーター応答 (30〜50 rad/s)
推奨: ωc ≈ 20〜40 rad/s (3〜6 Hz)
```

※ 慣性モーメントが小さいため角加速度は大きくなりやすいが、
  モーター応答が律速となり、帯域はブラシレス機より低めになる。

#### チューニング手順

1. **目標帯域 ωc を決定**（上記制約から）
2. **Kp を調整**してゲイン交差周波数を ωc 付近に
3. **Ti を調整**して低周波ゲインを確保しつつ位相を維持
   - Ti > 5/ωc 程度で積分の位相遅れが帯域に影響しにくい
4. **Td を調整**して位相余裕を改善
   - 位相進み効果で PM を増加
5. **位相余裕を確認**し、60°程度になるよう微調整

### 8.2 Ziegler-Nicholsの限界感度法（参考）

> **注意**: この方法は歴史的に有名だが、実際の性能は必ずしも良くない。
> 初期値の目安として参考にする程度に留め、最終調整は上記の周波数領域法や実機での調整で行うこと。

1. I, D を無効化（Ti=∞, Td=0）
2. Kp を上げて振動が持続する点を探す（限界ゲイン Ku）
3. 振動周期 Tu を測定
4. 以下の表でパラメータ設定

| 制御器 | Kp | Ti | Td |
|--------|----|----|-----|
| P | 0.5·Ku | - | - |
| PI | 0.45·Ku | Tu/1.2 | - |
| PID | 0.6·Ku | Tu/2 | Tu/8 |

この方法で得られる制御系は位相余裕が小さく（約20°）、振動的な応答になりやすい。

### 8.3 実践的な実機チューニング

理論的な初期値を設定した後、実機で微調整する手順:

1. **安全なゲインから開始**
   - 計算値の50%程度から
2. **P のみで応答確認**
   - ステップ応答で振動しないことを確認
3. **D を追加**
   - 振動を抑制、応答を改善
4. **I を追加**
   - 定常偏差を確認しながら徐々に追加
5. **飛行テストで最終調整**
   - ホバリング安定性
   - 外乱応答（手で押してみる）
   - 操縦感

### 8.4 ドローン角速度制御の目安

| 軸 | Kp | Ti | Td | η | 備考 |
|----|----|----|-----|---|------|
| Roll/Pitch | 0.1〜0.5 | 0.5〜2.0 | 0.01〜0.05 | 0.1 | 機体慣性に依存 |
| Yaw | 0.1〜0.3 | 0.5〜1.0 | 0.01〜0.03 | 0.1 | モーメント小さい |

※ 機体・モーター・プロペラにより大きく異なる。上記は初期値の目安。

---

## 9. 参考文献

- 川田昌克, 西岡勝博 『PID制御の基礎と応用』 森北出版
- Åström, K.J., Hägglund, T. "PID Controllers: Theory, Design, and Tuning" ISA
- Franklin, Powell, Emami-Naeini "Feedback Control of Dynamic Systems"

---

*最終更新: 2025-12-29*
